<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Definitions and conventions · Spglib.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://singularitti.github.io/Spglib.jl/man/definitions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Spglib.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation Guide</a></li><li class="is-active"><a class="tocitem" href>Definitions and conventions</a><ul class="internal"><li><a class="tocitem" href="#Basis-vectors"><span>Basis vectors</span></a></li><li><a class="tocitem" href="#Crystal-coordinates"><span>Crystal coordinates</span></a></li><li><a class="tocitem" href="#Space-group-operation-and-change-of-basis"><span>Space group operation and change of basis</span></a></li><li><a class="tocitem" href="#Spglib-conventions-of-standardized-unit-cell"><span>Spglib conventions of standardized unit cell</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../lib/public/">Public API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/internals/error/">Error</a></li><li><a class="tocitem" href="../../lib/internals/reciprocal/">Brillouin zone meshes</a></li></ul></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../developers/style-guide/">Style Guide</a></li><li><a class="tocitem" href="../../developers/design-principles/">Design Principles</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Definitions and conventions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Definitions and conventions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/singularitti/Spglib.jl/blob/main/docs/src/man/definitions.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Definitions-and-conventions"><a class="docs-heading-anchor" href="#Definitions-and-conventions">Definitions and conventions</a><a id="Definitions-and-conventions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions-and-conventions" title="Permalink"></a></h1><ul><li><a href="#Definitions-and-conventions">Definitions and conventions</a></li><li class="no-marker"><ul><li><a href="#Basis-vectors">Basis vectors</a></li><li><a href="#Crystal-coordinates">Crystal coordinates</a></li><li><a href="#Space-group-operation-and-change-of-basis">Space group operation and change of basis</a></li><li class="no-marker"><ul><li><a href="#Symmetry-operation-(\\mathbf{W},-\\mathbf{w})">Symmetry operation <span>$(\mathbf{W}, \mathbf{w})$</span></a></li><li><a href="#Transformation-matrix-\\mathbf{P}-and-origin-shift-\\mathbf{p}">Transformation matrix <span>$\mathbf{P}$</span> and origin shift <span>$\mathbf{p}$</span></a></li><li><a href="#Difference-between-rotation-and-transformation-matrices">Difference between rotation and transformation matrices</a></li></ul></li><li><a href="#Spglib-conventions-of-standardized-unit-cell">Spglib conventions of standardized unit cell</a></li><li class="no-marker"><ul><li><a href="#Transformation-to-the-primitive-cell">Transformation to the primitive cell</a></li><li><a href="#Idealization-of-unit-cell-structure">Idealization of unit cell structure</a></li><li><a href="#Rotation-introduced-by-idealization">Rotation introduced by idealization</a></li></ul></li></ul></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Our definitions and conventions are mostly adapted from <a href="https://spglib.readthedocs.io/en/latest/definition.html">here</a>, with some minor differences, such as the matrix representation of lattices.</p></div></div><h2 id="Basis-vectors"><a class="docs-heading-anchor" href="#Basis-vectors">Basis vectors</a><a id="Basis-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-vectors" title="Permalink"></a></h2><p>In this package, basis vectors are represented by three-column vectors:</p><p class="math-container">\[\mathbf{a} = \begin{bmatrix}
    a_x \\
    a_y \\
    a_z
\end{bmatrix},
\quad
\mathbf{b} = \begin{bmatrix}
    b_x \\
    b_y \\
    b_z
\end{bmatrix},
\quad
\mathbf{c} = \begin{bmatrix}
    c_x \\
    c_y \\
    c_z
\end{bmatrix},\]</p><p>in Cartesian coordinates. Depending on the situation, <span>$\begin{bmatrix} \mathbf{a}_1 &amp; \mathbf{a}_2 &amp; \mathbf{a}_3 \end{bmatrix}$</span> is used instead of <span>$\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix}$</span>.</p><p>Therefore, a lattice is represented as</p><p class="math-container">\[\mathbf{A} =
\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} =
\begin{bmatrix}
    a_x &amp; b_x &amp; c_x \\
    a_y &amp; b_y &amp; c_y \\
    a_z &amp; b_z &amp; c_z
\end{bmatrix}.\]</p><p>A reciprocal lattice is its inverse, represented as three row vectors:</p><p class="math-container">\[\mathbf{B} =
\mathbf{A}^{-1} =
\begin{bmatrix}
    \mathbf{b}_1 \\
    \mathbf{b}_2 \\
    \mathbf{b}_3
\end{bmatrix},\]</p><p>so that</p><p class="math-container">\[\mathbf{A} \mathbf{B} = \mathbf{B} \mathbf{A} = \mathbf{I},\]</p><p>where <span>$\mathbf{I}$</span> is the <span>$3 \times 3$</span> identity matrix.</p><h2 id="Crystal-coordinates"><a class="docs-heading-anchor" href="#Crystal-coordinates">Crystal coordinates</a><a id="Crystal-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Crystal-coordinates" title="Permalink"></a></h2><p>Coordinates of an atomic point <span>$\mathbf{x}$</span> are represented as three fractional values relative to basis vectors as follows,</p><p class="math-container">\[\mathbf{x} = \begin{bmatrix}
    x_1 \\
    x_2 \\
    x_3
\end{bmatrix},\]</p><p>where <span>$0 \le x_i &lt; 1$</span>. A position vector <span>$\mathbf{r}$</span> in Cartesian coordinates is obtained by</p><p class="math-container">\[\mathbf{r} = \mathbf{A} \mathbf{x} =
\begin{bmatrix} \mathbf{a}_1 &amp; \mathbf{a}_2 &amp; \mathbf{a}_3 \end{bmatrix}
\begin{bmatrix}
    x_1 \\
    x_2 \\
    x_3
\end{bmatrix}\]</p><p>or</p><p class="math-container">\[\mathbf{r} = \sum_i x_i \mathbf{a}_i.\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the Python version of Spglib, lattice parameters <code>lattice</code> are given by a <span>$3\times 3$</span> matrix with floating point values, where <span>$\mathbf{a}$</span>, <span>$\mathbf{b}$</span>, <span>$\mathbf{c}$</span> are given as rows, which results in the transpose of the definition for C-API. That is, in Python, the basis vectors are written as <a href="https://spglib.readthedocs.io/en/latest/variable.html#lattice">follows</a>:</p><pre><code class="language-python hljs">[ [ a_x, b_x, c_x ],
  [ a_y, b_y, c_y ],
  [ a_z, b_z, c_z ] ]</code></pre><p>Here, we adopt the C-API convention, i.e., writing basis vectors as columns.</p></div></div><h2 id="Space-group-operation-and-change-of-basis"><a class="docs-heading-anchor" href="#Space-group-operation-and-change-of-basis">Space group operation and change of basis</a><a id="Space-group-operation-and-change-of-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Space-group-operation-and-change-of-basis" title="Permalink"></a></h2><h3 id="Symmetry-operation-(\\mathbf{W},-\\mathbf{w})"><a class="docs-heading-anchor" href="#Symmetry-operation-(\\mathbf{W},-\\mathbf{w})">Symmetry operation <span>$(\mathbf{W}, \mathbf{w})$</span></a><a id="Symmetry-operation-(\\mathbf{W},-\\mathbf{w})-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry-operation-(\\mathbf{W},-\\mathbf{w})" title="Permalink"></a></h3><p>A symmetry operation consists of a pair of the rotation part <span>$\mathbf{W}$</span> and translation part <span>$\mathbf{w}$</span>, and is represented as <span>$(\mathbf{W}, \mathbf{w})$</span>. The symmetry operation transfers <span>$\mathbf{x}$</span> to <span>$\tilde{\mathbf{x}}$</span> as follows:</p><p class="math-container">\[\tilde{\mathbf{x}} = \mathbf{W} \mathbf{x} + \mathbf{w}.\]</p><h3 id="Transformation-matrix-\\mathbf{P}-and-origin-shift-\\mathbf{p}"><a class="docs-heading-anchor" href="#Transformation-matrix-\\mathbf{P}-and-origin-shift-\\mathbf{p}">Transformation matrix <span>$\mathbf{P}$</span> and origin shift <span>$\mathbf{p}$</span></a><a id="Transformation-matrix-\\mathbf{P}-and-origin-shift-\\mathbf{p}-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-matrix-\\mathbf{P}-and-origin-shift-\\mathbf{p}" title="Permalink"></a></h3><p>The transformation matrix <span>$\mathbf{P}$</span> changes choice of basis vectors as follows</p><p class="math-container">\[\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} =
\begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix}
\mathbf{P},\]</p><p>where <span>$\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix}$</span> and <span>$\begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix}$</span> are the basis vectors of an arbitrary system and of a standardized system, respectively. In general, the transformation matrix is not limited for the transformation from the standardized system, but can be used in between any systems possibly transformed. It has to be emphasized that the transformation matrix does not rotate a crystal in Cartesian coordinates, but just changes the choices of basis vectors.</p><h3 id="Difference-between-rotation-and-transformation-matrices"><a class="docs-heading-anchor" href="#Difference-between-rotation-and-transformation-matrices">Difference between rotation and transformation matrices</a><a id="Difference-between-rotation-and-transformation-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Difference-between-rotation-and-transformation-matrices" title="Permalink"></a></h3><p>A rotation matrix rotates (or mirrors, inverts) the crystal body with respect to origin. A transformation matrix changes the choice of the basis vectors, but does not rotate the crystal body.</p><h4 id="Active/reverse/alibi-transformation"><a class="docs-heading-anchor" href="#Active/reverse/alibi-transformation">Active/reverse/alibi transformation</a><a id="Active/reverse/alibi-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Active/reverse/alibi-transformation" title="Permalink"></a></h4><p>A space group operation having no translation part sends an atom to another point by</p><p class="math-container">\[\tilde{\mathbf{x}} = \mathbf{W} \mathbf{x},\]</p><p>where <span>$\tilde{\mathbf{x}}$</span> and <span>$\mathbf{x}$</span> are represented with respect to the same basis vectors <span>$\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix}$</span>. Equivalently the rotation is achieved by rotating the basis vectors:</p><p class="math-container">\[\begin{bmatrix} \tilde{\mathbf{a}} &amp; \tilde{\mathbf{b}} &amp; \tilde{\mathbf{c}} \end{bmatrix} =
\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} \mathbf{W}\]</p><p>with keeping the representation of the atomic point coordinates <span>$\mathbf{x}$</span> because</p><p class="math-container">\[\tilde{\mathbf{x}} = \begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix}
\tilde{\mathbf{x}} =
\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} \mathbf{W} \mathbf{x} =
\begin{bmatrix} \tilde{\mathbf{a}} &amp; \tilde{\mathbf{b}} &amp; \tilde{\mathbf{c}} \end{bmatrix}
\mathbf{x}.\]</p><h4 id="Passive/forward/alias-transformation"><a class="docs-heading-anchor" href="#Passive/forward/alias-transformation">Passive/forward/alias transformation</a><a id="Passive/forward/alias-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Passive/forward/alias-transformation" title="Permalink"></a></h4><p>The transformation matrix changes the choice of the basis vectors as:</p><p class="math-container">\[\begin{bmatrix} \mathbf{a}&#39; &amp; \mathbf{b}&#39; &amp; \mathbf{c}&#39; \end{bmatrix} =
\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} \mathbf{P}.\]</p><p>The atomic position vector is not altered by this transformation, i.e.,</p><p class="math-container">\[\begin{bmatrix} \mathbf{a}&#39; &amp; \mathbf{b}&#39; &amp; \mathbf{c}&#39; \end{bmatrix} \mathbf{x}&#39; =
\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} \mathbf{x}.\]</p><p>However the representation of the atomic point coordinates changes as follows:</p><p class="math-container">\[\mathbf{P} \mathbf{x}&#39; = \mathbf{x}.\]</p><p>because</p><p class="math-container">\[\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} \mathbf{P} \mathbf{x}&#39; =
\begin{bmatrix} \mathbf{a}&#39; &amp; \mathbf{b}&#39; &amp; \mathbf{c}&#39; \end{bmatrix} \mathbf{x}&#39; =
\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} \mathbf{x}.\]</p><h2 id="Spglib-conventions-of-standardized-unit-cell"><a class="docs-heading-anchor" href="#Spglib-conventions-of-standardized-unit-cell">Spglib conventions of standardized unit cell</a><a id="Spglib-conventions-of-standardized-unit-cell-1"></a><a class="docs-heading-anchor-permalink" href="#Spglib-conventions-of-standardized-unit-cell" title="Permalink"></a></h2><h3 id="Transformation-to-the-primitive-cell"><a class="docs-heading-anchor" href="#Transformation-to-the-primitive-cell">Transformation to the primitive cell</a><a id="Transformation-to-the-primitive-cell-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-to-the-primitive-cell" title="Permalink"></a></h3><p>In the standardized unit cells, there are five different centring types available, base centerings of A and C, rhombohedral (R), body-centred (I), and face-centred (F). The transformation is applied to the standardized unit cell by</p><p class="math-container">\[\begin{bmatrix} \mathbf{a}_\text{p} &amp; \mathbf{b}_\text{p} &amp; \mathbf{c}_\text{p} \end{bmatrix} =
\begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix}
\mathbf{P}\]</p><p>where <span>$\mathbf{a}_\text{p}$</span>, <span>$\mathbf{b}_\text{p}$</span>, and <span>$\mathbf{c}_\text{p}$</span> are the basis vectors of the primitive cell and <span>$\mathbf{P}$</span> is the transformation matrix from the standardized unit cell to the primitive cell. Matrices <span>$\mathbf{P}$</span> for different centring types are given as follows:</p><p class="math-container">\[\mathbf{P}_\text{A} = \begin{bmatrix}
    1 &amp; 0 &amp; 0 \\
    0 &amp; \dfrac{1}{2} &amp; \dfrac{-1}{2} \\
    0 &amp; \dfrac{1}{2} &amp; \dfrac{1}{2}
\end{bmatrix},
\quad
\mathbf{P}_\text{C} = \begin{bmatrix}
    \dfrac{1}{2} &amp; \dfrac{1}{2} &amp; 0 \\
    \dfrac{-1}{2} &amp; \dfrac{1}{2} &amp; 0 \\
    0 &amp; 0 &amp; 1
\end{bmatrix},
\quad
\mathbf{P}_\text{R} = \begin{bmatrix}
    \dfrac{2}{3} &amp; \dfrac{-1}{3} &amp; \dfrac{-1}{3} \\
    \dfrac{1}{3} &amp; \dfrac{1}{3} &amp; \dfrac{\bar{2}}{3} \\
    \dfrac{1}{3} &amp; \dfrac{1}{3} &amp; \dfrac{1}{3}
\end{bmatrix},
\quad
\mathbf{P}_\text{I} = \begin{bmatrix}
    \dfrac{-1}{2} &amp; \dfrac{1}{2} &amp; \dfrac{1}{2} \\
    \dfrac{1}{2} &amp; \dfrac{-1}{2} &amp; \dfrac{1}{2} \\
    \dfrac{1}{2} &amp; \dfrac{1}{2} &amp; \dfrac{-1}{2}
\end{bmatrix},
\quad
\mathbf{P}_\text{F} = \begin{bmatrix}
    0 &amp; \dfrac{1}{2} &amp; \dfrac{1}{2} \\
    \dfrac{1}{2} &amp; 0 &amp; \dfrac{1}{2} \\
    \dfrac{1}{2} &amp; \dfrac{1}{2} &amp; 0
\end{bmatrix}.\]</p><p>The choice of transformation matrix depends on the purpose.</p><p>For rhombohedral lattice systems with the H setting (hexagonal lattice), <span>$\mathbf{P}_\text{R}$</span> is applied to obtain primitive basis vectors. However, with the R setting (rhombohedral lattice), no transformation matrix is used because it is already a primitive cell.</p><h3 id="Idealization-of-unit-cell-structure"><a class="docs-heading-anchor" href="#Idealization-of-unit-cell-structure">Idealization of unit cell structure</a><a id="Idealization-of-unit-cell-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Idealization-of-unit-cell-structure" title="Permalink"></a></h3><p>Spglib allows tolerance parameters to match a slightly distorted unit cell structure to a space group type with some higher symmetry. Using obtained symmetry operations, the distortion is removed to idealize the unit cell structure. The coordinates of atomic points are idealized using respective site-symmetries (Grosse-Kunstleve <em>et al</em>. (2002)). The basis vectors are idealized by forcing them into respective lattice shapes as follows. In this treatment, except for triclinic crystals, crystals can be rotated in Cartesian coordinates, which is the different type of transformation from that of the change-of-basis transformation explained above.</p><h4 id="Triclinic-lattice"><a class="docs-heading-anchor" href="#Triclinic-lattice">Triclinic lattice</a><a id="Triclinic-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Triclinic-lattice" title="Permalink"></a></h4><ul><li>Niggli-reduced cell is used for choosing <span>$\mathbf{a}$</span>, <span>$\mathbf{b}$</span>, and <span>$\mathbf{c}$</span>.</li><li><span>$\mathbf{a}$</span> is set along <span>$+x$</span> direction of Cartesian coordinates.</li><li><span>$\mathbf{b}$</span> is set in <span>$x$</span>-<span>$y$</span> plane of Cartesian coordinates so that <span>$\mathbf{a}\times\mathbf{b}$</span> is along <span>$+z$</span> direction of Cartesian coordinates.</li></ul><h4 id="Monoclinic-lattice"><a class="docs-heading-anchor" href="#Monoclinic-lattice">Monoclinic lattice</a><a id="Monoclinic-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Monoclinic-lattice" title="Permalink"></a></h4><ul><li>The <span>$b$</span>-axis is taken as the unique axis.</li><li><span>$\alpha = 90^\circ$</span> and <span>$\gamma = 90^\circ$</span>, while <span>$90^\circ &lt; \beta &lt; 120^\circ$</span>.</li><li><span>$\mathbf{a}$</span> is set along <span>$+x$</span> direction of Cartesian coordinates.</li><li><span>$\mathbf{b}$</span> is set along <span>$+y$</span> direction of Cartesian coordinates.</li><li><span>$\mathbf{c}$</span> is set in <span>$x$</span>-<span>$z$</span> plane of Cartesian coordinates.</li></ul><h4 id="Orthorhombic-lattice"><a class="docs-heading-anchor" href="#Orthorhombic-lattice">Orthorhombic lattice</a><a id="Orthorhombic-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Orthorhombic-lattice" title="Permalink"></a></h4><ul><li><span>$\alpha = \beta = \gamma = 90^\circ$</span>.</li><li><span>$\mathbf{a}$</span> is set along <span>$+x$</span> direction of Cartesian coordinates.</li><li><span>$\mathbf{b}$</span> is set along <span>$+y$</span> direction of Cartesian coordinates.</li><li><span>$\mathbf{c}$</span> is set along <span>$+z$</span> direction of Cartesian coordinates.</li></ul><h4 id="Tetragonal-lattice"><a class="docs-heading-anchor" href="#Tetragonal-lattice">Tetragonal lattice</a><a id="Tetragonal-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Tetragonal-lattice" title="Permalink"></a></h4><ul><li><span>$\alpha = \beta = \gamma = 90^\circ$</span>.</li><li><span>$a=b$</span>.</li><li><span>$\mathbf{a}$</span> is set along <span>$+x$</span> direction of Cartesian coordinates.</li><li><span>$\mathbf{b}$</span> is set along <span>$+y$</span> direction of Cartesian coordinates.</li><li><span>$\mathbf{c}$</span> is set along <span>$+z$</span> direction of Cartesian coordinates.</li></ul><h4 id="Rhombohedral-lattice"><a class="docs-heading-anchor" href="#Rhombohedral-lattice">Rhombohedral lattice</a><a id="Rhombohedral-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Rhombohedral-lattice" title="Permalink"></a></h4><ul><li><span>$\alpha = \beta = \gamma$</span>.</li><li><span>$a=b=c$</span>.</li><li>Let <span>$\mathbf{a}$</span>, <span>$\mathbf{b}$</span>, and <span>$\mathbf{c}$</span> projected on <span>$x$</span>-<span>$y$</span> plane in Cartesian coordinates be <span>$\mathbf{a}_{xy}$</span>, <span>$\mathbf{b}_{xy}$</span>, and <span>$\mathbf{c}_{xy}$</span>, respectively, and their angles be <span>$\alpha_{xy}$</span>, <span>$\beta_{xy}$</span>, <span>$\gamma_{xy}$</span>, respectively.</li><li>Let <span>$\mathbf{a}$</span>, <span>$\mathbf{b}$</span>, and <span>$\mathbf{c}$</span> projected along <span>$z$</span>-axis in Cartesian coordinates be <span>$\mathbf{a}_{z}$</span>, <span>$\mathbf{b}_{z}$</span>, and <span>$\mathbf{c}_{z}$</span>, respectively.</li><li><span>$\mathbf{a}_{xy}$</span> is set along the ray <span>$30^\circ$</span> rotated counter-clockwise from the <span>$+x$</span> direction of Cartesian coordinates, and <span>$\mathbf{b}_{xy}$</span> and <span>$\mathbf{c}_{xy}$</span> are placed by angles <span>$120^\circ$</span> and <span>$240^\circ$</span> from <span>$\mathbf{a}_{xy}$</span> counter-clockwise, respectively.</li><li><span>$\alpha_{xy} = \beta_{xy} = \gamma_{xy} = 120^\circ$</span>.</li><li><span>$a_{xy} = b_{xy} = c_{xy}$</span>.</li><li><span>$a_{z} = b_{z} = c_{z}$</span>.</li></ul><h4 id="Hexagonal-lattice"><a class="docs-heading-anchor" href="#Hexagonal-lattice">Hexagonal lattice</a><a id="Hexagonal-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Hexagonal-lattice" title="Permalink"></a></h4><ul><li><span>$\alpha = \beta = 90^\circ$</span>, <span>$\gamma = 120^\circ$</span>.</li><li><span>$a=b$</span>.</li><li><span>$\mathbf{a}$</span> is set along <span>$+x$</span> direction of Cartesian coordinates.</li><li><span>$\mathbf{b}$</span> is set in <span>$x$</span>-<span>$y$</span> plane of Cartesian coordinates.</li><li><span>$\mathbf{c}$</span> is set along <span>$+z$</span> direction of Cartesian coordinates.</li></ul><h4 id="Cubic-lattice"><a class="docs-heading-anchor" href="#Cubic-lattice">Cubic lattice</a><a id="Cubic-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Cubic-lattice" title="Permalink"></a></h4><ul><li><span>$\alpha = \beta = \gamma = 90^\circ$</span>.</li><li><span>$a=b=c$</span>.</li><li><span>$\mathbf{a}$</span> is set along <span>$+x$</span> direction of Cartesian coordinates.</li><li><span>$\mathbf{b}$</span> is set along <span>$+y$</span> direction of Cartesian coordinates.</li><li><span>$\mathbf{c}$</span> is set along <span>$+z$</span> direction of Cartesian coordinates.</li></ul><h3 id="Rotation-introduced-by-idealization"><a class="docs-heading-anchor" href="#Rotation-introduced-by-idealization">Rotation introduced by idealization</a><a id="Rotation-introduced-by-idealization-1"></a><a class="docs-heading-anchor-permalink" href="#Rotation-introduced-by-idealization" title="Permalink"></a></h3><p>In the idealization step presented above, the input unit cell crystal structure can be rotated in the Cartesian coordinates.  The rotation matrix <span>$\mathbf{R}$</span> of this rotation is defined by</p><p class="math-container">\[\begin{bmatrix} \bar{\mathbf{a}}_\text{s} &amp; \bar{\mathbf{b}}_\text{s} &amp; \bar{\mathbf{c}}_\text{s} \end{bmatrix} =
\mathbf{R} \begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix}.\]</p><p>This rotation matrix rotates the standardized crystal structure before idealization <span>$\mathbf{R} \begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix}$</span> to that after idealization <span>$\begin{bmatrix} \bar{\mathbf{a}}_\text{s} &amp; \bar{\mathbf{b}}_\text{s} &amp; \bar{\mathbf{c}}_\text{s} \end{bmatrix}$</span> in Cartesian coordinates of the given input unit cell.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../installation/">« Installation Guide</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 17 August 2023 01:18">Thursday 17 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
