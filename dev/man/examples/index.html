<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Spglib.jl</title><meta name="title" content="Examples · Spglib.jl"/><meta property="og:title" content="Examples · Spglib.jl"/><meta property="twitter:title" content="Examples · Spglib.jl"/><meta name="description" content="Documentation for Spglib.jl."/><meta property="og:description" content="Documentation for Spglib.jl."/><meta property="twitter:description" content="Documentation for Spglib.jl."/><meta property="og:url" content="https://singularitti.github.io/Spglib.jl/man/examples/"/><meta property="twitter:url" content="https://singularitti.github.io/Spglib.jl/man/examples/"/><link rel="canonical" href="https://singularitti.github.io/Spglib.jl/man/examples/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Spglib.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation Guide</a></li><li><a class="tocitem" href="../definitions/">Definitions and conventions</a></li><li><a class="tocitem" href="../dataset/">Spglib dataset</a></li><li><a class="tocitem" href="../magnetic_dataset/">Magnetic dataset (experimental)</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-Cell"><span>Creating a <code>Cell</code></span></a></li><li><a class="tocitem" href="#Crystallographic-choice-and-rigid-rotation"><span>Crystallographic choice and rigid rotation</span></a></li><li><a class="tocitem" href="#Transformation-to-a-primitive-cell"><span>Transformation to a primitive cell</span></a></li><li><a class="tocitem" href="#Computing-rigid-rotation-introduced-by-idealization"><span>Computing rigid rotation introduced by idealization</span></a></li></ul></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../lib/public/">Public API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/internals/error/">Error</a></li><li><a class="tocitem" href="../../lib/internals/reciprocal/">Brillouin zone meshes</a></li></ul></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../developers/style-guide/">Style Guide</a></li><li><a class="tocitem" href="../../developers/design-principles/">Design Principles</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/singularitti/Spglib.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/singularitti/Spglib.jl/blob/main/docs/src/man/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><ul><li><a href="#Examples">Examples</a></li><li class="no-marker"><ul><li><a href="#Creating-a-Cell">Creating a <code>Cell</code></a></li><li><a href="#Crystallographic-choice-and-rigid-rotation">Crystallographic choice and rigid rotation</a></li><li><a href="#Transformation-to-a-primitive-cell">Transformation to a primitive cell</a></li><li><a href="#Computing-rigid-rotation-introduced-by-idealization">Computing rigid rotation introduced by idealization</a></li></ul></li></ul><h2 id="Creating-a-Cell"><a class="docs-heading-anchor" href="#Creating-a-Cell">Creating a <code>Cell</code></a><a id="Creating-a-Cell-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Cell" title="Permalink"></a></h2><p>To create a <code>Cell</code>, we first need to create a <code>Lattice</code>. Then we can add atoms and their positions (in crystal coordinates):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Spglib</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; lattice = [
           -3.0179389205999998 -3.0179389205999998 0.0000000000000000
           -5.2272235447000002 5.2272235447000002 0.0000000000000000
           0.0000000000000000 0.0000000000000000 -9.7736219469000005
       ]</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
 -3.01794  -3.01794   0.0
 -5.22722   5.22722   0.0
  0.0       0.0      -9.77362</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; positions = [[2 / 3, 1 / 3, 1 / 4], [1 / 3, 2 / 3, 3 / 4]]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Vector{Float64}}:
 [0.6666666666666666, 0.3333333333333333, 0.25]
 [0.3333333333333333, 0.6666666666666666, 0.75]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = [1, 1]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cell = Cell(lattice, positions, atoms)</code><code class="nohighlight hljs ansi" style="display:block;">SpglibCell{Float64, Float64, Int64, Float64}
 lattice:
   -3.0179389206  -3.0179389206  0.0
   -5.2272235447  5.2272235447  0.0
   0.0  0.0  -9.7736219469
 2 atomic positions:
   0.6666666666666666  0.3333333333333333  0.25
   0.3333333333333333  0.6666666666666666  0.75
 2 atoms:
   1  1</code></pre><h2 id="Crystallographic-choice-and-rigid-rotation"><a class="docs-heading-anchor" href="#Crystallographic-choice-and-rigid-rotation">Crystallographic choice and rigid rotation</a><a id="Crystallographic-choice-and-rigid-rotation-1"></a><a class="docs-heading-anchor-permalink" href="#Crystallographic-choice-and-rigid-rotation" title="Permalink"></a></h2><p>The following example of a python script gives a crystal structure of Br whose space group type is <em>Cmce</em>. The basis vectors <span>$\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix}$</span> are fixed by the symmetry crystal in the standardization. The C-centering determines the c-axis, and <em>m</em> and <em>c</em> operations in <em>Cmce</em> fix which directions a- and b-axes should be with respect to each other axis. This is the first one choice appearing in the list of Hall symbols among 6 different choices for this space group type.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Spglib</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; lattice = Lattice([[7.17851431, 0, 0],  # a
                          [0, 3.99943947, 0],  # b
                          [0, 0, 8.57154746]])  # c</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Lattice{Float64}
 7.17851431  0.0  0.0
 0.0  3.99943947  0.0
 0.0  0.0  8.57154746</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; positions = [[0.0, 0.84688439, 0.1203133],
                    [0.0, 0.65311561, 0.6203133],
                    [0.0, 0.34688439, 0.3796867],
                    [0.0, 0.15311561, 0.8796867],
                    [0.5, 0.34688439, 0.1203133],
                    [0.5, 0.15311561, 0.6203133],
                    [0.5, 0.84688439, 0.3796867],
                    [0.5, 0.65311561, 0.8796867]];</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = fill(35, length(positions));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cell = Cell(lattice, positions, atoms)</code><code class="nohighlight hljs ansi" style="display:block;">SpglibCell{Float64, Float64, Int64, Float64}
 lattice:
   7.17851431  0.0  0.0
   0.0  3.99943947  0.0
   0.0  0.0  8.57154746
 8 atomic positions:
   0.0  0.84688439  0.1203133
   0.0  0.65311561  0.6203133
   0.0  0.34688439  0.3796867
   0.0  0.15311561  0.8796867
   0.5  0.34688439  0.1203133
   0.5  0.15311561  0.6203133
   0.5  0.84688439  0.3796867
   0.5  0.65311561  0.8796867
 8 atoms:
   35  35  35  35  35  35  35  35</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset = get_dataset(cell, 1e-5)</code><code class="nohighlight hljs ansi" style="display:block;">Dataset
  spacegroup_number: 64
  hall_number: 304
  international_symbol: Cmce
  hall_symbol: -C 2bc 2
  choice:
  transformation_matrix: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
  origin_shift: [0.0, 0.0, 0.0]
  n_operations: 16
  rotations: StaticArraysCore.SMatrix{3, 3, Int32, 9}[[1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 -1 0; 0 0 -1], [-1 0 0; 0 -1 0; 0 0 1], [1 0 0; 0 1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 -1], [-1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 1], [1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 -1 0; 0 0 -1], [-1 0 0; 0 -1 0; 0 0 1], [1 0 0; 0 1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 -1], [-1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 1]]
  translations: StaticArraysCore.SVector{3, Float64}[[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.5, 0.5], [0.0, 0.5, 0.5], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.5, 0.5], [0.0, 0.5, 0.5], [0.5, 0.5, 0.0], [0.5, 0.5, 0.0], [0.5, 0.0, 0.5], [0.5, 0.0, 0.5], [0.5, 0.5, 0.0], [0.5, 0.5, 0.0], [0.5, 0.0, 0.5], [0.5, 0.0, 0.5]]
  n_atoms: 8
  wyckoffs: [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
  site_symmetry_symbols: [&quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;]
  equivalent_atoms: Int32[1, 1, 1, 1, 1, 1, 1, 1]
  crystallographic_orbits: Int32[1, 1, 1, 1, 1, 1, 1, 1]
  primitive_lattice: [0.0 3.589257155 0.0; -3.99943947 1.999719735 0.0; 0.0 0.0 8.57154746]
  mapping_to_primitive: Int32[1, 2, 3, 4, 1, 2, 3, 4]
  n_std_atoms: 8
  std_lattice: [7.17851431 0.0 0.0; 0.0 3.99943947 0.0; 0.0 0.0 8.57154746]
  std_types: Int32[1, 1, 1, 1, 1, 1, 1, 1]
  std_positions: StaticArraysCore.SVector{3, Float64}[[0.0, 0.84688439, 0.1203133], [0.0, 0.65311561, 0.6203133], [0.0, 0.34688439000000004, 0.3796867], [0.0, 0.15311560999999996, 0.8796867], [0.5, 0.34688439000000004, 0.1203133], [0.5, 0.15311560999999996, 0.6203133], [0.5, 0.84688439, 0.3796867], [0.5, 0.65311561, 0.8796867]]
  std_rotation_matrix: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
  std_mapping_to_primitive: Int32[1, 2, 3, 4, 1, 2, 3, 4]
  pointgroup_symbol: mmm</code></pre><p>we get</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Space group type: &quot;, dataset.international_symbol)</code><code class="nohighlight hljs ansi" style="display:block;">Space group type: Cmce</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Space group number: &quot;, dataset.spacegroup_number)</code><code class="nohighlight hljs ansi" style="display:block;">Space group number: 64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Transformation matrix: &quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Transformation matrix:</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset.transformation_matrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 StaticArraysCore.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Origin shift: &quot;, dataset.origin_shift)</code><code class="nohighlight hljs ansi" style="display:block;">Origin shift: [0.0, 0.0, 0.0]</code></pre><p>No rotation was introduced in the idealization. Next, we swap the a- and c-axes.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; lattice = Lattice([[8.57154746, 0, 0],  # a
                          [0, 3.99943947, 0],  # b
                          [0, 0, 7.17851431]])  # c</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Lattice{Float64}
 8.57154746  0.0  0.0
 0.0  3.99943947  0.0
 0.0  0.0  7.17851431</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; positions = [[0.1203133, 0.84688439, 0.0],
                    [0.6203133, 0.65311561, 0.0],
                    [0.3796867, 0.34688439, 0.0],
                    [0.8796867, 0.15311561, 0.0],
                    [0.1203133, 0.34688439, 0.5],
                    [0.6203133, 0.15311561, 0.5],
                    [0.3796867, 0.84688439, 0.5],
                    [0.8796867, 0.65311561, 0.5]];</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = fill(35, length(positions));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cell = Cell(lattice, positions, atoms)</code><code class="nohighlight hljs ansi" style="display:block;">SpglibCell{Float64, Float64, Int64, Float64}
 lattice:
   8.57154746  0.0  0.0
   0.0  3.99943947  0.0
   0.0  0.0  7.17851431
 8 atomic positions:
   0.1203133  0.84688439  0.0
   0.6203133  0.65311561  0.0
   0.3796867  0.34688439  0.0
   0.8796867  0.15311561  0.0
   0.1203133  0.34688439  0.5
   0.6203133  0.15311561  0.5
   0.3796867  0.84688439  0.5
   0.8796867  0.65311561  0.5
 8 atoms:
   35  35  35  35  35  35  35  35</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset = get_dataset(cell, 1e-5)</code><code class="nohighlight hljs ansi" style="display:block;">Dataset
  spacegroup_number: 64
  hall_number: 304
  international_symbol: Cmce
  hall_symbol: -C 2bc 2
  choice:
  transformation_matrix: [0.0 0.0 1.0; 0.0 1.0 0.0; -1.0 0.0 0.0]
  origin_shift: [0.0, 0.0, 0.0]
  n_operations: 16
  rotations: StaticArraysCore.SMatrix{3, 3, Int32, 9}[[1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 -1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 -1], [-1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 -1 0; 0 0 1], [1 0 0; 0 1 0; 0 0 -1], [-1 0 0; 0 1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 1], [1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 -1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 -1], [-1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 -1 0; 0 0 1], [1 0 0; 0 1 0; 0 0 -1], [-1 0 0; 0 1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 1]]
  translations: StaticArraysCore.SVector{3, Float64}[[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.5, 0.5, 0.0], [0.5, 0.5, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.5, 0.5, 0.0], [0.5, 0.5, 0.0], [0.0, 0.5, 0.5], [0.0, 0.5, 0.5], [0.5, 0.0, 0.5], [0.5, 0.0, 0.5], [0.0, 0.5, 0.5], [0.0, 0.5, 0.5], [0.5, 0.0, 0.5], [0.5, 0.0, 0.5]]
  n_atoms: 8
  wyckoffs: [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
  site_symmetry_symbols: [&quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;]
  equivalent_atoms: Int32[1, 1, 1, 1, 1, 1, 1, 1]
  crystallographic_orbits: Int32[1, 1, 1, 1, 1, 1, 1, 1]
  primitive_lattice: [0.0 0.0 8.57154746; 3.99943947 1.999719735 0.0; 0.0 3.589257155 0.0]
  mapping_to_primitive: Int32[1, 2, 3, 4, 1, 2, 3, 4]
  n_std_atoms: 8
  std_lattice: [7.17851431 0.0 0.0; 0.0 3.99943947 0.0; 0.0 0.0 8.57154746]
  std_types: Int32[1, 1, 1, 1, 1, 1, 1, 1]
  std_positions: StaticArraysCore.SVector{3, Float64}[[0.0, 0.84688439, 0.8796867], [0.0, 0.65311561, 0.37968670000000015], [0.0, 0.34688439000000004, 0.6203133], [0.0, 0.15311560999999996, 0.12031329999999996], [0.5, 0.34688439000000004, 0.8796867], [0.5, 0.15311560999999996, 0.37968670000000015], [0.5, 0.84688439, 0.6203133], [0.5, 0.65311561, 0.12031329999999996]]
  std_rotation_matrix: [0.0 0.0 1.0; 0.0 1.0 0.0; -1.0 0.0 0.0]
  std_mapping_to_primitive: Int32[1, 2, 3, 4, 1, 2, 3, 4]
  pointgroup_symbol: mmm</code></pre><p>By this, we get</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Space group type: &quot;, dataset.international_symbol)</code><code class="nohighlight hljs ansi" style="display:block;">Space group type: Cmce</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Space group number: &quot;, dataset.spacegroup_number)</code><code class="nohighlight hljs ansi" style="display:block;">Space group number: 64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Transformation matrix: &quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Transformation matrix:</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset.transformation_matrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 StaticArraysCore.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.0  0.0  1.0
  0.0  1.0  0.0
 -1.0  0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Origin shift: &quot;, dataset.origin_shift)</code><code class="nohighlight hljs ansi" style="display:block;">Origin shift: [0.0, 0.0, 0.0]</code></pre><p>We get a non-identity transformation matrix, which wants to transform back to the original (above) crystal structure by swapping a- and c-axes. The transformation back of the basis vectors is achieved by</p><p class="math-container">\[\begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} =
\begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix}
\mathbf{P},\]</p><p>Next, we try to rotate rigidly the crystal structure by <span>$45^\circ$</span> around c-axis in Cartesian coordinates from the first one:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; lattice = Lattice([[5.0759761474456697, 5.0759761474456697, 0],  # a
                          [-2.8280307701821314, 2.8280307701821314, 0],  # b
                          [0, 0, 8.57154746]])  # c</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Lattice{Float64}
 5.07597614744567  -2.8280307701821314  0.0
 5.07597614744567  2.8280307701821314  0.0
 0.0  0.0  8.57154746</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; positions = [[0.0, 0.84688439, 0.1203133],
                    [0.0, 0.65311561, 0.6203133],
                    [0.0, 0.34688439, 0.3796867],
                    [0.0, 0.15311561, 0.8796867],
                    [0.5, 0.34688439, 0.1203133],
                    [0.5, 0.15311561, 0.6203133],
                    [0.5, 0.84688439, 0.3796867],
                    [0.5, 0.65311561, 0.8796867]];</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = fill(35, length(positions));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cell = Cell(lattice, positions, atoms)</code><code class="nohighlight hljs ansi" style="display:block;">SpglibCell{Float64, Float64, Int64, Float64}
 lattice:
   5.07597614744567  -2.8280307701821314  0.0
   5.07597614744567  2.8280307701821314  0.0
   0.0  0.0  8.57154746
 8 atomic positions:
   0.0  0.84688439  0.1203133
   0.0  0.65311561  0.6203133
   0.0  0.34688439  0.3796867
   0.0  0.15311561  0.8796867
   0.5  0.34688439  0.1203133
   0.5  0.15311561  0.6203133
   0.5  0.84688439  0.3796867
   0.5  0.65311561  0.8796867
 8 atoms:
   35  35  35  35  35  35  35  35</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset = get_dataset(cell, 1e-5)</code><code class="nohighlight hljs ansi" style="display:block;">Dataset
  spacegroup_number: 64
  hall_number: 304
  international_symbol: Cmce
  hall_symbol: -C 2bc 2
  choice:
  transformation_matrix: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
  origin_shift: [5.551115123125783e-17, 0.0, 0.0]
  n_operations: 16
  rotations: StaticArraysCore.SMatrix{3, 3, Int32, 9}[[1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 -1 0; 0 0 -1], [-1 0 0; 0 -1 0; 0 0 1], [1 0 0; 0 1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 -1], [-1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 1], [1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 -1 0; 0 0 -1], [-1 0 0; 0 -1 0; 0 0 1], [1 0 0; 0 1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 -1], [-1 0 0; 0 1 0; 0 0 1], [-1 0 0; 0 1 0; 0 0 -1], [1 0 0; 0 -1 0; 0 0 1]]
  translations: StaticArraysCore.SVector{3, Float64}[[0.0, 0.0, 0.0], [-1.1102230246251565e-16, 2.465190328815662e-32, 0.0], [-1.1102230246251565e-16, 0.5, 0.5], [0.0, 0.5, 0.5], [0.0, 0.0, 0.0], [-1.1102230246251565e-16, 2.465190328815662e-32, 0.0], [-1.1102230246251565e-16, 0.5, 0.5], [0.0, 0.5, 0.5], [0.5, 0.5, 0.0], [0.4999999999999999, 0.5, 0.0], [0.4999999999999999, 0.0, 0.5], [0.5, 0.0, 0.5], [0.5, 0.5, 0.0], [0.4999999999999999, 0.5, 0.0], [0.4999999999999999, 0.0, 0.5], [0.5, 0.0, 0.5]]
  n_atoms: 8
  wyckoffs: [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
  site_symmetry_symbols: [&quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;, &quot;m..&quot;]
  equivalent_atoms: Int32[1, 1, 1, 1, 1, 1, 1, 1]
  crystallographic_orbits: Int32[1, 1, 1, 1, 1, 1, 1, 1]
  primitive_lattice: [2.8280307701821314 1.1239726886317691 0.0; -2.8280307701821314 3.9520034588139006 0.0; 0.0 0.0 8.57154746]
  mapping_to_primitive: Int32[1, 2, 3, 4, 1, 2, 3, 4]
  n_std_atoms: 8
  std_lattice: [7.178514309999999 0.0 0.0; 0.0 3.99943947 0.0; 0.0 0.0 8.57154746]
  std_types: Int32[1, 1, 1, 1, 1, 1, 1, 1]
  std_positions: StaticArraysCore.SVector{3, Float64}[[0.0, 0.84688439, 0.1203133], [0.0, 0.65311561, 0.6203133], [0.0, 0.34688439000000004, 0.3796867], [0.0, 0.15311560999999996, 0.8796867], [0.5, 0.34688439000000004, 0.1203133], [0.5, 0.15311560999999996, 0.6203133], [0.5, 0.84688439, 0.3796867], [0.5, 0.65311561, 0.8796867]]
  std_rotation_matrix: [0.7071067811865475 0.7071067811865475 0.0; -0.7071067811865475 0.7071067811865475 0.0; 0.0 0.0 1.0]
  std_mapping_to_primitive: Int32[1, 2, 3, 4, 1, 2, 3, 4]
  pointgroup_symbol: mmm</code></pre><p>and</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Space group type: &quot;, dataset.international_symbol)</code><code class="nohighlight hljs ansi" style="display:block;">Space group type: Cmce</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Space group number: &quot;, dataset.spacegroup_number)</code><code class="nohighlight hljs ansi" style="display:block;">Space group number: 64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Transformation matrix: &quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Transformation matrix:</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset.transformation_matrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 StaticArraysCore.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(&quot;Origin shift: &quot;, dataset.origin_shift)</code><code class="nohighlight hljs ansi" style="display:block;">Origin shift: [5.551115123125783e-17, 0.0, 0.0]</code></pre><p>The transformation matrix is kept unchanged even though the crystal structure is rotated in Cartesian coordinates. The origin shift is different but it changes only the order of atoms, so effectively it does nothing.</p><h2 id="Transformation-to-a-primitive-cell"><a class="docs-heading-anchor" href="#Transformation-to-a-primitive-cell">Transformation to a primitive cell</a><a id="Transformation-to-a-primitive-cell-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-to-a-primitive-cell" title="Permalink"></a></h2><p>There are infinite number of choices of primitive cell. The transformation from a primitive cell basis vectors to the other primitive cell basis vectors is always done by an integer matrix because any lattice points can be generated by the linear combination of the three primitive basis vectors.</p><p>When we have a non-primitive cell basis vectors as given in the above example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Spglib</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; lattice = Lattice([[7.17851431, 0, 0],  # a
                          [0, 3.99943947, 0],  # b
                          [0, 0, 8.57154746]])  # c</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Lattice{Float64}
 7.17851431  0.0  0.0
 0.0  3.99943947  0.0
 0.0  0.0  8.57154746</code></pre><p>This has the C-centring, so it must be transformed to a primitive cell. A possible transformation is shown at <a href="../definitions/#Transformation-to-the-primitive-cell">Transformation to the primitive cell</a>, which is <span>$\mathbf{P}_\text{C}$</span>. With the following script:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pc = [
               1//2 1//2 0
               -1//2 1//2 0
               0 0 1
           ]</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Rational{Int64}}:
  1//2  1//2  0
 -1//2  1//2  0
   0     0    1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; primitive_lattice = lattice * Pc</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
  3.58926  3.58926  0.0
 -1.99972  1.99972  0.0
  0.0      0.0      8.57155</code></pre><p>we get the primitive cell basis vectors <code>primitive_lattice</code>.</p><p><code>find_primitive</code> gives a primitive cell that is obtained by transforming standardized and idealized crystal structure to the primitive cell using the transformation matrix. Therefore by this script we get:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; positions = [
           [0.0, 0.84688439, 0.1203133],
           [0.0, 0.65311561, 0.6203133],
           [0.0, 0.34688439, 0.3796867],
           [0.0, 0.15311561, 0.8796867],
           [0.5, 0.34688439, 0.1203133],
           [0.5, 0.15311561, 0.6203133],
           [0.5, 0.84688439, 0.3796867],
           [0.5, 0.65311561, 0.8796867],
       ];</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = fill(8, length(positions));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cell = Cell(lattice, positions, atoms)</code><code class="nohighlight hljs ansi" style="display:block;">SpglibCell{Float64, Float64, Int64, Float64}
 lattice:
   7.17851431  0.0  0.0
   0.0  3.99943947  0.0
   0.0  0.0  8.57154746
 8 atomic positions:
   0.0  0.84688439  0.1203133
   0.0  0.65311561  0.6203133
   0.0  0.34688439  0.3796867
   0.0  0.15311561  0.8796867
   0.5  0.34688439  0.1203133
   0.5  0.15311561  0.6203133
   0.5  0.84688439  0.3796867
   0.5  0.65311561  0.8796867
 8 atoms:
   8  8  8  8  8  8  8  8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; find_primitive(cell).lattice</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Lattice{Float64}
 3.589257155  3.589257155  0.0
 -1.999719735  1.999719735  0.0
 0.0  0.0  8.57154746</code></pre><p>This is same as what we manually obtained above. Even when the basis vectors are rigidly rotated as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; new_lattice = Lattice([[5.0759761474456697, 5.0759761474456697, 0],
                              [-2.8280307701821314, 2.8280307701821314, 0],
                              [0, 0, 8.57154746]])</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Lattice{Float64}
 5.07597614744567  -2.8280307701821314  0.0
 5.07597614744567  2.8280307701821314  0.0
 0.0  0.0  8.57154746</code></pre><p>the relationship of <span>$a$</span>, <span>$b$</span>, <span>$c$</span> axes is unchanged. Therefore the same transformation matrix to the primitive cell can be used. Then we get:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; new_lattice * Pc</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
 3.952    1.12397  0.0
 1.12397  3.952    0.0
 0.0      0.0      8.57155</code></pre><p>However applying <code>find_primitive</code> rigidly rotates automatically and so the following script doesn&#39;t give this basis vectors:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; lattice = Lattice([
           [5.0759761474456697, 5.0759761474456697, 0],
           [-2.8280307701821314, 2.8280307701821314, 0],
           [0, 0, 8.57154746],
       ])</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Lattice{Float64}
 5.07597614744567  -2.8280307701821314  0.0
 5.07597614744567  2.8280307701821314  0.0
 0.0  0.0  8.57154746</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; positions = [
           [0.0, 0.84688439, 0.1203133],
           [0.0, 0.65311561, 0.6203133],
           [0.0, 0.34688439, 0.3796867],
           [0.0, 0.15311561, 0.8796867],
           [0.5, 0.34688439, 0.1203133],
           [0.5, 0.15311561, 0.6203133],
           [0.5, 0.84688439, 0.3796867],
           [0.5, 0.65311561, 0.8796867],
       ];</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = fill(8, length(positions));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cell = Cell(lattice, positions, atoms)</code><code class="nohighlight hljs ansi" style="display:block;">SpglibCell{Float64, Float64, Int64, Float64}
 lattice:
   5.07597614744567  -2.8280307701821314  0.0
   5.07597614744567  2.8280307701821314  0.0
   0.0  0.0  8.57154746
 8 atomic positions:
   0.0  0.84688439  0.1203133
   0.0  0.65311561  0.6203133
   0.0  0.34688439  0.3796867
   0.0  0.15311561  0.8796867
   0.5  0.34688439  0.1203133
   0.5  0.15311561  0.6203133
   0.5  0.84688439  0.3796867
   0.5  0.65311561  0.8796867
 8 atoms:
   8  8  8  8  8  8  8  8</code></pre><p>but gives those with respect to the idealized ones:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; find_primitive(cell).lattice</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Lattice{Float64}
 3.5892571549999994  3.5892571549999994  0.0
 -1.999719735  1.999719735  0.0
 0.0  0.0  8.57154746</code></pre><p>To obtain the rotated primitive cell basis vectors, we can use <code>standardize_cell</code> as shown below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; standardize_cell(cell, to_primitive=true, no_idealize=true).lattice</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Lattice{Float64}
 3.9520034588139006  1.1239726886317691  0.0
 1.1239726886317691  3.9520034588139006  0.0
 0.0  0.0  8.57154746</code></pre><p>which is equivalent to that we get manually. However, using <code>standardize_cell</code>, distortion is not removed for the distorted crystal structure.</p><h2 id="Computing-rigid-rotation-introduced-by-idealization"><a class="docs-heading-anchor" href="#Computing-rigid-rotation-introduced-by-idealization">Computing rigid rotation introduced by idealization</a><a id="Computing-rigid-rotation-introduced-by-idealization-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-rigid-rotation-introduced-by-idealization" title="Permalink"></a></h2><p>This example is from <a href="https://spglib.readthedocs.io/en/latest/definition.html#computing-rigid-rotation-introduced-by-idealization">here</a>.</p><p>In this package, rigid rotation is purposely introduced in the idealization step though this is unlikely as a crystallographic operation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StaticArrays, Spglib</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: Package StaticArrays not found in current path.
- Run `import Pkg; Pkg.add(&quot;StaticArrays&quot;)` to install the StaticArrays package.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; lattice = Lattice([
           [5.0759761474456697, 5.0759761474456697, 0],
           [-2.8280307701821314, 2.8280307701821314, 0],
           [0, 0, 8.57154746],
       ]);</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `Lattice` not defined in `Main`
Suggestion: check for spelling errors or missing imports.
Hint: a global variable of this name may be made accessible by importing CrystallographyCore in the current active module Main
Hint: a global variable of this name also exists in Spglib.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; positions = [
           [0.0, 0.84688439, 0.1203133],
           [0.0, 0.65311561, 0.6203133],
           [0.0, 0.34688439, 0.3796867],
           [0.0, 0.15311561, 0.8796867],
           [0.5, 0.34688439, 0.1203133],
           [0.5, 0.15311561, 0.6203133],
           [0.5, 0.84688439, 0.3796867],
           [0.5, 0.65311561, 0.8796867],
       ];</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = fill(35, length(positions));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cell = Cell(lattice, positions, atoms)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `Cell` not defined in `Main`
Suggestion: check for spelling errors or missing imports.
Hint: a global variable of this name may be made accessible by importing CrystallographyCore in the current active module Main
Hint: a global variable of this name also exists in Spglib.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset = get_dataset(cell, 1e-5)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `get_dataset` not defined in `Main`
Suggestion: check for spelling errors or missing imports.
Hint: a global variable of this name also exists in Spglib.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset.international_symbol</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `dataset` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset.spacegroup_number</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `dataset` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset.transformation_matrix</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `dataset` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code></pre><p>We can see the transformation matrix from the given lattice to the standardized lattice is the identity matrix, i.e., the given lattice is already a standardized lattice.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; std_lattice_before_idealization = convert(Matrix{Float64}, lattice) * inv(dataset.transformation_matrix)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `lattice` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code></pre><p>This is based on formula in <a href="../definitions/#Transformation-matrix-\\mathbf{P}-and-origin-shift-\\mathbf{p}">Transformation matrix <span>$\mathbf{P}$</span> and origin shift <span>$\mathbf{p}$</span></a> and <a href="../definitions/#Passive/forward/alias-transformation">Passive/forward/alias transformation</a>:</p><p class="math-container">\[\begin{align}
    \begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} &amp;=
    \begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix}
    \mathbf{P},\\
    \therefore \begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix} &amp;=
    \begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} \mathbf{P}^{-1}.
\end{align}\]</p><p>Here, <span>$\mathbf{P}$</span> is the <code>dataset.transformation_matrix</code>.</p><p>Note that in contrast to the Python code:</p><pre><code class="language-python hljs">std_lattice_before_idealization = np.dot(
    np.transpose(lattice),
    np.linalg.inv(dataset[&#39;transformation_matrix&#39;])).T</code></pre><p>where there are multiple transpose operations, we do not have to do that in our Julia code since we choose a column-major order of stacking lattice vectors as described in <a href="../definitions/#Basis-vectors">Basis vectors</a>, and we return transformation matrix in column-major order, too.</p><p>Now, we obtain the standardized basis vectors after idealization <span>$\begin{bmatrix} \bar{\mathbf{a}}_\text{s} &amp; \bar{\mathbf{b}}_\text{s} &amp; \bar{\mathbf{c}}_\text{s} \end{bmatrix}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; std_lattice_after_idealization = dataset.std_lattice</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `dataset` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code></pre><p>This is different from the standardized basis vectors before idealization <span>$\begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix}$</span>. Unless this crystal structure is distorted from the crystal structure that has the ideal symmetry, this means that the crystal was rotated rigidly in the idealization step by</p><p class="math-container">\[\begin{bmatrix} \bar{\mathbf{a}}_\text{s} &amp; \bar{\mathbf{b}}_\text{s} &amp; \bar{\mathbf{c}}_\text{s} \end{bmatrix} =
\mathbf{R} \begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix},\]</p><p>as stated in <a href="../definitions/#Rotation-introduced-by-idealization">Rotation introduced by idealization</a>. where <span>$\mathbf{R}$</span> is the rotation matrix. This is computed by</p><p class="math-container">\[\mathbf{R} =
\begin{bmatrix} \bar{\mathbf{a}}_\text{s} &amp; \bar{\mathbf{b}}_\text{s} &amp; \bar{\mathbf{c}}_\text{s} \end{bmatrix}
\begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix}^{-1}\]</p><p>In Julia code, this is</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐀 = convert(Matrix{Float64}, std_lattice_after_idealization)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `std_lattice_after_idealization` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐁 = convert(Matrix{Float64}, std_lattice_before_idealization)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `std_lattice_before_idealization` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐑 = 𝐀 * inv(𝐁)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `𝐀` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code></pre><p>Note also the transpose is not applied here in contrast to the Python code:</p><pre><code class="language-python hljs">R = np.dot(dataset[&#39;std_lattice&#39;].T, np.linalg.inv(std_lattice_before_idealization.T))</code></pre><p>This equals to</p><p class="math-container">\[\begin{bmatrix}
    \cos \theta &amp; -\sin \theta &amp; 0\\
    \sin \theta &amp; \cos \theta &amp; 0\\
    0 &amp; 0 &amp; 1
\end{bmatrix}\]</p><p>where <span>$\theta = -\pi/4$</span> and <span>$\det(\mathbf{R}) = 1$</span> when no distortion:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ = -π/4</code><code class="nohighlight hljs ansi" style="display:block;">-0.7853981633974483</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [
           cos(θ) -sin(θ) 0
           sin(θ) cos(θ) 0
           0 0 1
       ]</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
  0.707107  0.707107  0.0
 -0.707107  0.707107  0.0
  0.0       0.0       1.0</code></pre><p>Compared to <code>dataset.std_rotation_matrix</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dataset.std_rotation_matrix</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `dataset` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code></pre><p>we have approximately the same result.</p><p>In summary of the two steps,</p><p class="math-container">\[\begin{align}
    \begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix} =
    \begin{bmatrix} \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \end{bmatrix} \mathbf{P}^{-1} &amp;=
    \mathbf{R}^{-1}
    \begin{bmatrix} \bar{\mathbf{a}}_\text{s} &amp; \bar{\mathbf{b}}_\text{s} &amp; \bar{\mathbf{c}}_\text{s} \end{bmatrix},\\
    \begin{bmatrix} \bar{\mathbf{a}}_\text{s} &amp; \bar{\mathbf{b}}_\text{s} &amp; \bar{\mathbf{c}}_\text{s} \end{bmatrix}
    \mathbf{P} &amp;=
    \mathbf{R} \begin{bmatrix} \mathbf{a}_\text{s} &amp; \mathbf{b}_\text{s} &amp; \mathbf{c}_\text{s} \end{bmatrix}.
\end{align}\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../magnetic_dataset/">« Magnetic dataset (experimental)</a><a class="docs-footer-nextpage" href="../troubleshooting/">Troubleshooting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 18 September 2025 17:10">Thursday 18 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
