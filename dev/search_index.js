var documenterSearchIndex = {"docs":
[{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 2:2","category":"section"},{"location":"man/examples/#Creating-a-Cell","page":"Examples","title":"Creating a Cell","text":"To create a Cell, we first need to create a Lattice. Then we can add atoms and their positions (in crystal coordinates):\n\nusing Spglib\nlattice = [\n    -3.0179389205999998 -3.0179389205999998 0.0000000000000000\n    -5.2272235447000002 5.2272235447000002 0.0000000000000000\n    0.0000000000000000 0.0000000000000000 -9.7736219469000005\n]\npositions = [[2 / 3, 1 / 3, 1 / 4], [1 / 3, 2 / 3, 3 / 4]]\natoms = [1, 1]\ncell = Cell(lattice, positions, atoms)","category":"section"},{"location":"man/examples/#Crystallographic-choice-and-rigid-rotation","page":"Examples","title":"Crystallographic choice and rigid rotation","text":"The following example of a python script gives a crystal structure of Br whose space group type is Cmce. The basis vectors beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix are fixed by the symmetry crystal in the standardization. The C-centering determines the c-axis, and m and c operations in Cmce fix which directions a- and b-axes should be with respect to each other axis. This is the first one choice appearing in the list of Hall symbols among 6 different choices for this space group type.\n\nusing Spglib\nlattice = Lattice([[7.17851431, 0, 0],  # a\n                   [0, 3.99943947, 0],  # b\n                   [0, 0, 8.57154746]])  # c\npositions = [[0.0, 0.84688439, 0.1203133],\n             [0.0, 0.65311561, 0.6203133],\n             [0.0, 0.34688439, 0.3796867],\n             [0.0, 0.15311561, 0.8796867],\n             [0.5, 0.34688439, 0.1203133],\n             [0.5, 0.15311561, 0.6203133],\n             [0.5, 0.84688439, 0.3796867],\n             [0.5, 0.65311561, 0.8796867]];\natoms = fill(35, length(positions));\ncell = Cell(lattice, positions, atoms)\ndataset = get_dataset(cell, 1e-5)\n\nwe get\n\nprint(\"Space group type: \", dataset.international_symbol)\nprint(\"Space group number: \", dataset.spacegroup_number)\nprint(\"Transformation matrix: \")\ndataset.transformation_matrix\nprint(\"Origin shift: \", dataset.origin_shift)\n\nNo rotation was introduced in the idealization. Next, we swap the a- and c-axes.\n\nlattice = Lattice([[8.57154746, 0, 0],  # a\n                   [0, 3.99943947, 0],  # b\n                   [0, 0, 7.17851431]])  # c\npositions = [[0.1203133, 0.84688439, 0.0],\n             [0.6203133, 0.65311561, 0.0],\n             [0.3796867, 0.34688439, 0.0],\n             [0.8796867, 0.15311561, 0.0],\n             [0.1203133, 0.34688439, 0.5],\n             [0.6203133, 0.15311561, 0.5],\n             [0.3796867, 0.84688439, 0.5],\n             [0.8796867, 0.65311561, 0.5]];\natoms = fill(35, length(positions));\ncell = Cell(lattice, positions, atoms)\ndataset = get_dataset(cell, 1e-5)\n\nBy this, we get\n\nprint(\"Space group type: \", dataset.international_symbol)\nprint(\"Space group number: \", dataset.spacegroup_number)\nprint(\"Transformation matrix: \")\ndataset.transformation_matrix\nprint(\"Origin shift: \", dataset.origin_shift)\n\nWe get a non-identity transformation matrix, which wants to transform back to the original (above) crystal structure by swapping a- and c-axes. The transformation back of the basis vectors is achieved by\n\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix =\nbeginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix\nmathbfP\n\nNext, we try to rotate rigidly the crystal structure by 45^circ around c-axis in Cartesian coordinates from the first one:\n\nlattice = Lattice([[5.0759761474456697, 5.0759761474456697, 0],  # a\n                   [-2.8280307701821314, 2.8280307701821314, 0],  # b\n                   [0, 0, 8.57154746]])  # c\npositions = [[0.0, 0.84688439, 0.1203133],\n             [0.0, 0.65311561, 0.6203133],\n             [0.0, 0.34688439, 0.3796867],\n             [0.0, 0.15311561, 0.8796867],\n             [0.5, 0.34688439, 0.1203133],\n             [0.5, 0.15311561, 0.6203133],\n             [0.5, 0.84688439, 0.3796867],\n             [0.5, 0.65311561, 0.8796867]];\natoms = fill(35, length(positions));\ncell = Cell(lattice, positions, atoms)\ndataset = get_dataset(cell, 1e-5)\n\nand\n\nprint(\"Space group type: \", dataset.international_symbol)\nprint(\"Space group number: \", dataset.spacegroup_number)\nprint(\"Transformation matrix: \")\ndataset.transformation_matrix\nprint(\"Origin shift: \", dataset.origin_shift)\n\nThe transformation matrix is kept unchanged even though the crystal structure is rotated in Cartesian coordinates. The origin shift is different but it changes only the order of atoms, so effectively it does nothing.","category":"section"},{"location":"man/examples/#Transformation-to-a-primitive-cell","page":"Examples","title":"Transformation to a primitive cell","text":"There are infinite number of choices of primitive cell. The transformation from a primitive cell basis vectors to the other primitive cell basis vectors is always done by an integer matrix because any lattice points can be generated by the linear combination of the three primitive basis vectors.\n\nWhen we have a non-primitive cell basis vectors as given in the above example:\n\nusing Spglib\nlattice = Lattice([[7.17851431, 0, 0],  # a\n                   [0, 3.99943947, 0],  # b\n                   [0, 0, 8.57154746]])  # c\n\nThis has the C-centring, so it must be transformed to a primitive cell. A possible transformation is shown at Transformation to the primitive cell, which is mathbfP_textC. With the following script:\n\nPc = [\n        1//2 1//2 0\n        -1//2 1//2 0\n        0 0 1\n    ]\nprimitive_lattice = lattice * Pc\n\nwe get the primitive cell basis vectors primitive_lattice.\n\nfind_primitive gives a primitive cell that is obtained by transforming standardized and idealized crystal structure to the primitive cell using the transformation matrix. Therefore by this script we get:\n\npositions = [\n    [0.0, 0.84688439, 0.1203133],\n    [0.0, 0.65311561, 0.6203133],\n    [0.0, 0.34688439, 0.3796867],\n    [0.0, 0.15311561, 0.8796867],\n    [0.5, 0.34688439, 0.1203133],\n    [0.5, 0.15311561, 0.6203133],\n    [0.5, 0.84688439, 0.3796867],\n    [0.5, 0.65311561, 0.8796867],\n];\natoms = fill(8, length(positions));\ncell = Cell(lattice, positions, atoms)\nfind_primitive(cell).lattice\n\nThis is same as what we manually obtained above. Even when the basis vectors are rigidly rotated as:\n\nnew_lattice = Lattice([[5.0759761474456697, 5.0759761474456697, 0],\n                       [-2.8280307701821314, 2.8280307701821314, 0],\n                       [0, 0, 8.57154746]])\n\nthe relationship of a, b, c axes is unchanged. Therefore the same transformation matrix to the primitive cell can be used. Then we get:\n\nnew_lattice * Pc\n\nHowever applying find_primitive rigidly rotates automatically and so the following script doesn't give this basis vectors:\n\nlattice = Lattice([\n    [5.0759761474456697, 5.0759761474456697, 0],\n    [-2.8280307701821314, 2.8280307701821314, 0],\n    [0, 0, 8.57154746],\n])\npositions = [\n    [0.0, 0.84688439, 0.1203133],\n    [0.0, 0.65311561, 0.6203133],\n    [0.0, 0.34688439, 0.3796867],\n    [0.0, 0.15311561, 0.8796867],\n    [0.5, 0.34688439, 0.1203133],\n    [0.5, 0.15311561, 0.6203133],\n    [0.5, 0.84688439, 0.3796867],\n    [0.5, 0.65311561, 0.8796867],\n];\natoms = fill(8, length(positions));\ncell = Cell(lattice, positions, atoms)\n\nbut gives those with respect to the idealized ones:\n\nfind_primitive(cell).lattice\n\nTo obtain the rotated primitive cell basis vectors, we can use standardize_cell as shown below:\n\nstandardize_cell(cell, to_primitive=true, no_idealize=true).lattice\n\nwhich is equivalent to that we get manually. However, using standardize_cell, distortion is not removed for the distorted crystal structure.","category":"section"},{"location":"man/examples/#Computing-rigid-rotation-introduced-by-idealization","page":"Examples","title":"Computing rigid rotation introduced by idealization","text":"This example is from here.\n\nIn this package, rigid rotation is purposely introduced in the idealization step though this is unlikely as a crystallographic operation.\n\nusing StaticArrays, Spglib\nlattice = Lattice([\n    [5.0759761474456697, 5.0759761474456697, 0],\n    [-2.8280307701821314, 2.8280307701821314, 0],\n    [0, 0, 8.57154746],\n]);\npositions = [\n    [0.0, 0.84688439, 0.1203133],\n    [0.0, 0.65311561, 0.6203133],\n    [0.0, 0.34688439, 0.3796867],\n    [0.0, 0.15311561, 0.8796867],\n    [0.5, 0.34688439, 0.1203133],\n    [0.5, 0.15311561, 0.6203133],\n    [0.5, 0.84688439, 0.3796867],\n    [0.5, 0.65311561, 0.8796867],\n];\natoms = fill(35, length(positions));\ncell = Cell(lattice, positions, atoms)\ndataset = get_dataset(cell, 1e-5)\ndataset.international_symbol\ndataset.spacegroup_number\ndataset.transformation_matrix\n\nWe can see the transformation matrix from the given lattice to the standardized lattice is the identity matrix, i.e., the given lattice is already a standardized lattice.\n\nstd_lattice_before_idealization = convert(Matrix{Float64}, lattice) * inv(dataset.transformation_matrix)\n\nThis is based on formula in Transformation matrix mathbfP and origin shift mathbfp and Passive/forward/alias transformation:\n\nbeginalign\n    beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix =\n    beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix\n    mathbfP\n    therefore beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix =\n    beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfP^-1\nendalign\n\nHere, mathbfP is the dataset.transformation_matrix.\n\nNote that in contrast to the Python code:\n\nstd_lattice_before_idealization = np.dot(\n    np.transpose(lattice),\n    np.linalg.inv(dataset['transformation_matrix'])).T\n\nwhere there are multiple transpose operations, we do not have to do that in our Julia code since we choose a column-major order of stacking lattice vectors as described in Basis vectors, and we return transformation matrix in column-major order, too.\n\nNow, we obtain the standardized basis vectors after idealization beginbmatrix barmathbfa_texts  barmathbfb_texts  barmathbfc_texts endbmatrix:\n\nstd_lattice_after_idealization = dataset.std_lattice\n\nThis is different from the standardized basis vectors before idealization beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix. Unless this crystal structure is distorted from the crystal structure that has the ideal symmetry, this means that the crystal was rotated rigidly in the idealization step by\n\nbeginbmatrix barmathbfa_texts  barmathbfb_texts  barmathbfc_texts endbmatrix =\nmathbfR beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix\n\nas stated in Rotation introduced by idealization. where mathbfR is the rotation matrix. This is computed by\n\nmathbfR =\nbeginbmatrix barmathbfa_texts  barmathbfb_texts  barmathbfc_texts endbmatrix\nbeginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix^-1\n\nIn Julia code, this is\n\nð€ = convert(Matrix{Float64}, std_lattice_after_idealization)\nð = convert(Matrix{Float64}, std_lattice_before_idealization)\nð‘ = ð€ * inv(ð)\n\nNote also the transpose is not applied here in contrast to the Python code:\n\nR = np.dot(dataset['std_lattice'].T, np.linalg.inv(std_lattice_before_idealization.T))\n\nThis equals to\n\nbeginbmatrix\n    cos theta  -sin theta  0\n    sin theta  cos theta  0\n    0  0  1\nendbmatrix\n\nwhere theta = -pi4 and det(mathbfR) = 1 when no distortion:\n\nÎ¸ = -Ï€/4\n[\n    cos(Î¸) -sin(Î¸) 0\n    sin(Î¸) cos(Î¸) 0\n    0 0 1\n]\n\nCompared to dataset.std_rotation_matrix:\n\ndataset.std_rotation_matrix\n\nwe have approximately the same result.\n\nIn summary of the two steps,\n\nbeginalign\n    beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix =\n    beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfP^-1 =\n    mathbfR^-1\n    beginbmatrix barmathbfa_texts  barmathbfb_texts  barmathbfc_texts endbmatrix\n    beginbmatrix barmathbfa_texts  barmathbfb_texts  barmathbfc_texts endbmatrix\n    mathbfP =\n    mathbfR beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix\nendalign","category":"section"},{"location":"lib/public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"lib/public/#Contents","page":"Public API","title":"Contents","text":"Pages = [\"public.md\"]\nDepth = 2","category":"section"},{"location":"lib/public/#Index","page":"Public API","title":"Index","text":"Pages = [\"public.md\"]","category":"section"},{"location":"lib/public/#Public-interface","page":"Public API","title":"Public interface","text":"To utilize the public interface, first import the required packages:\n\nusing CrystallographyCore, Spglib\n\nFor documentation on CrystallographyCore.jl, refer to this link.\n\nFor extended functionalities, consider exploring my other packages: CrystallographyBase.jl, Crystallography.jl, and MillerIndices.jl.","category":"section"},{"location":"lib/public/#Types","page":"Public API","title":"Types","text":"","category":"section"},{"location":"lib/public/#Functions","page":"Public API","title":"Functions","text":"You can find their official documentation on this page.","category":"section"},{"location":"lib/public/#CrystallographyCore.Lattice-Tuple{SpglibCell}","page":"Public API","title":"CrystallographyCore.Lattice","text":"Lattice(cell::SpglibCell)\n\nGet the lattice from a cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Spglib.Dataset","page":"Public API","title":"Spglib.Dataset","text":"Dataset(spacegroup_number, hall_number, international_symbol, hall_symbol, choice, transformation_matrix, origin_shift, n_operations, rotations, translations, n_atoms, wyckoffs, site_symmetry_symbols, equivalent_atoms, crystallographic_orbits, primitive_lattice, mapping_to_primitive, n_std_atoms, std_lattice, std_types, std_positions, std_rotation_matrix, std_mapping_to_primitive, pointgroup_symbol)\n\nRepresent SpglibDataset, see its official documentation.\n\nArguments\n\nspacegroup_number: international space group number.\nhall_number: Hall number. This number is used in get_symmetry_from_database and get_spacegroup_type.\ninternational_symbol: international short symbol.\nhall_symbol: Hall symbol.\nchoice: centring, origin, basis vector setting.\ntransformation_matrix: See the detail at Transformation matrix and origin shift.\norigin shift: See the detail at Transformation matrix and origin shift.\nn_operations: number of symmetry operations.\nrotations and translations: rotation matrices and translation vectors. See get_symmetry for more details.\nn_atoms: number of atoms in the input unit cell.\nwyckoffs: Wyckoff letters.\nsite_symmetry_symbols: site-symmetry symbols (experimental).\nequivalent_atoms: mapping table to equivalent atoms.\ncrystallographic_orbits : mapping table to equivalent atoms (see Wyckoff positions and symmetrically equivalent atoms for the difference between equivalent_atoms and crystallographic_orbits).\nprimitive_lattice : basis vectors of a primitive cell.\nmapping_to_primitive: mapping table to atoms in the primitive cell.\nn_std_atoms: number of atoms in the standardized unit cell.\nstd_lattice, std_positions, std_types: standardized crystal structure corresponding to the Hall symbol found. These are equivalently given in the array formats of lattice, positions, and atoms presented at SpglibCell, respectively.\nstd_rotation_matrix: see the detail at Standardized crystal structure after idealization.\nstd_mapping_to_primitive: Mapping table from atoms in the standardized crystal structure to the atoms in the primitive cell.\npointgroup_symbol: symbol of the crystallographic point group in the Hermannâ€“Mauguin notation.\n\nSee also get_dataset, get_dataset_with_hall_number.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Spglib.MagneticDataset","page":"Public API","title":"Spglib.MagneticDataset","text":"MagneticDataset(uni_number, msg_type, hall_number, tensor_rank, n_operations, rotations, translations, time_reversals, n_atoms, equivalent_atoms, transformation_matrix, origin_shift, n_std_atoms, std_lattice, std_types, std_positions, std_tensors, std_rotation_matrix, primitive_lattice)\n\nRepresent MagneticDataset, see its official documentation.\n\nArguments\n\nuni_number: UNI number, from 1 to 1651.\nmsg_type: Magnetic space groups (MSG) are classified by their family space group (FSG) and maximal space subgroup (XSG).\nThe FSG is the nonmagnetic space group obtained by ignoring time-reversal in the MSG. The XSG is the space group obtained by removing time-reversal operations from the MSG.\nmsg_type == 1 (type I): MSG, XSG, and FSG are all isomorphic.\nmsg_type == 2 (type II): XSG and FSG are isomorphic; the MSG is generated from the XSG and pure time-reversal operations.\nmsg_type == 3 (type III): The XSG is a proper subgroup of the MSG with isomorphic translational subgroups.\nmsg_type == 4 (type IV): The XSG is a proper subgroup of the MSG with an isomorphic point group.\nhall_number: Hall number of the FSG (types Iâ€“III) or of the XSG (type IV).\ntensor_rank: Rank of magmoms.\nn_operations: Number of magnetic symmetry operations.\nrotations: Rotation matrices of the magnetic symmetry operations.\ntranslations: Translation vectors of the magnetic symmetry operations.\ntime_reversals: Time-reversal flags for the magnetic symmetry operations. true indicates a time-reversal operation, and false indicates an ordinary operation.\nn_atoms: Number of atoms in the input cell.\nequivalent_atoms: Symmetrically equivalent atoms, where 'symmetrically equivalent' refers to the found symmetry operations.\ntransformation_matrix: Transformation matrix (3  3) from the input lattice to the standardized lattice.\norigin_shift: Origin shift from the standardized origin to the input origin.\nn_std_atoms: Number of atoms in the standardized unit cell.\nstd_lattice: Lattice vectors of the standardized unit cell.\nstd_types: Identity numbers of atoms in the standardized unit cell.\nstd_positions: Fractional coordinates of atoms in the standardized unit cell.\nstd_tensors: Magnetic moments in the standardized unit cell: a length-n_std_atoms vector of scalars for collinear moments, or a length-n_std_atoms vector of 3-vectors for noncollinear moments.\nstd_rotation_matrix: Rigid rotation matrix from the standardized basis vectors to an idealized, standardized, orthonormal basis.\nprimitive_lattice: Basis vectors of a primitive cell.\n\nSee also get_magnetic_dataset.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Spglib.MagneticSpacegroupType","page":"Public API","title":"Spglib.MagneticSpacegroupType","text":"MagneticSpacegroupType(uninumber, litvinnumber, bnsnumber, ognumber, number, type)\n\nRepresent SpglibMagneticSpacegroupType, see its official documentation.\n\nArguments\n\nuni_number::Int32: Serial number of UNI (or BNS) symbols.\nlitvin_number::Int32: Serial number in Litvin's Magnetic Group Tables.\nbns_number::String: BNS number, e.g. \"151.32\".\nog_number::String: OG number, e.g. \"153.4.1270\".\nnumber::Int32: ITA's serial number of space group for reference setting.\ntype::Int32: Type of MSG, from 1 to 4.\n\nSee also get_magnetic_spacegroup_type, get_magnetic_spacegroup_type_from_symmetry.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Spglib.SpacegroupType","page":"Public API","title":"Spglib.SpacegroupType","text":"SpacegroupType(number, international_short, international_full, international, schoenflies, hall_number, hall_symbol, choice, pointgroup_international, pointgroup_schoenflies, arithmetic_crystal_class_number, arithmetic_crystal_class_symbol)\n\nRepresent SpglibSpacegroupType, see its official documentation.\n\nSee also get_spacegroup_type, get_spacegroup_type_from_symmetry.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Spglib.SpglibCell","page":"Public API","title":"Spglib.SpglibCell","text":"SpglibCell(lattice, positions, atoms, magmoms=[])\n\nRepresent a unit cell with specified lattice, positions, atoms, and magnetic moments.\n\nArguments\n\nlattice: lattice of the unit cell. Lattice parameters are given by a 33 matrix with floating point values, where ðš, ð›, and ðœ are stored as columns. You could also give a vector of 3-vectors, where each vector is a lattice vector. See Basis vectors for our conventions and Lattice for more examples.\npositions: positions of the atoms in the unit cell. Fractional atomic positions are given by a vector of N 3-vectors with floating point values, where N is the number of atoms.\natoms: N atoms present in the unit cell.\nmagmoms=[]: magnetic moments on atoms in the unit cell (optional). It can be either a vector of N floating point values for collinear cases or a vector of 3-vectors in cartesian coordinates for non-collinear cases.\n\nSee also Lattice.\n\nExamples\n\njulia> lattice = Lattice([\n           [5.0759761474456697, 5.0759761474456697, 0],\n           [-2.8280307701821314, 2.8280307701821314, 0],\n           [0, 0, 8.57154746],\n       ]);\n\njulia> positions = [\n           [0.0, 0.84688439, 0.1203133],\n           [0.0, 0.65311561, 0.6203133],\n           [0.0, 0.34688439, 0.3796867],\n           [0.0, 0.15311561, 0.8796867],\n           [0.5, 0.34688439, 0.1203133],\n           [0.5, 0.15311561, 0.6203133],\n           [0.5, 0.84688439, 0.3796867],\n           [0.5, 0.65311561, 0.8796867],\n       ];\n\njulia> atoms = fill(35, length(positions));\n\njulia> cell = SpglibCell(lattice, positions, atoms);\n\njulia> lattice = Lattice([\n           4 0 0\n           0 4 0\n           0 0 3\n       ]);\n\njulia> positions = [\n           [0.0, 0.0, 0.0],\n           [0.5, 0.5, 0.5],\n           [0.3, 0.3, 0.0],\n           [0.7, 0.7, 0.0],\n           [0.2, 0.8, 0.5],\n           [0.8, 0.2, 0.5],\n       ];\n\njulia> atoms = [14, 14, 8, 8, 8, 8];\n\njulia> cell = SpglibCell(lattice, positions, atoms);\n\njulia> lattice = [\n           4.0 0.0 0.0\n           0.0 4.0 0.0\n           0.0 0.0 4.0\n       ];\n\njulia> positions = [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]];\n\njulia> atoms = [1, 1];\n\njulia> magmoms = [1.0, 1.0];\n\njulia> cell = SpglibCell(lattice, positions, atoms, magmoms);\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystallographyCore.atomtypes-Tuple{SpglibCell}","page":"Public API","title":"CrystallographyCore.atomtypes","text":"atomtypes(cell::SpglibCell)\n\nReturn the unique atom types in the specified cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CrystallographyCore.natoms-Tuple{SpglibCell}","page":"Public API","title":"CrystallographyCore.natoms","text":"natoms(cell::SpglibCell)\n\nReturn the number of atoms in the specified cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Spglib.delaunay_reduce","page":"Public API","title":"Spglib.delaunay_reduce","text":"delaunay_reduce(lattice::AbstractMatrix, symprec=1e-5)\ndelaunay_reduce(cell::Cell, symprec=1e-5)\n\nApply Delaunay reduction to input basis vectors lattice.\n\nThe transformation from original basis vectors  beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix to final basis vectors beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix is achieved by linear combination of basis vectors with integer coefficients without rotating coordinates. Therefore the transformation matrix is obtained by\n\nmathbfP = beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix^-1\n\nand the matrix elements have to be almost integers.\n\nSee also Computing rigid rotation introduced by idealization.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.eachpoint","page":"Public API","title":"Spglib.eachpoint","text":"eachpoint(result::BrillouinZoneMesh, ir_only=true)\n\nIterate over the points in the Brillouin zone mesh, with the option to include only irreducible k-points or all k-points.\n\nSee also BrillouinZoneMesh.\n\nnote: Note\nThis function only returns an iterator, not a vector of points. To get a vector, use collect(eachpoint(result, ir_only)).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.find_primitive","page":"Public API","title":"Spglib.find_primitive","text":"find_primitive(cell::AbstractCell, symprec=1e-5)\n\nFind the primitive cell of an input unit cell.\n\nThis function is now a shortcut of standardize_cell with to_primitive=true and no_idealize=false.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_dataset","page":"Public API","title":"Spglib.get_dataset","text":"get_dataset(cell::AbstractCell, symprec=1e-5)\n\nSearch symmetry operations of an input unit cell structure.\n\nFor an input unit cell structure, symmetry operations of the crystal are searched. Then they are compared with the crystallographic database and the space group type is determined.  The result is returned as the Dataset structure as a dataset.\n\nThe detail of the dataset is given at Dataset.\n\nDataset corresponding to the space group type in the standard setting is obtained by get_dataset. Here the standard setting means the first top one among the Hall symbols listed for each space group type. For example, H setting (hexagonal lattice) is chosen for rhombohedral crystals. get_dataset_with_hall_number explained below is used to choose different settings such as R setting of rhombohedral crystals. In this function, the other crystallographic setting is not obtained.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_dataset_with_hall_number","page":"Public API","title":"Spglib.get_dataset_with_hall_number","text":"get_dataset_with_hall_number(cell::AbstractCell, hall_number::Integer, symprec=1e-5)\n\nSearch symmetry operations of an input unit cell structure, using a given Hall number.\n\nFor an input unit cell structure, symmetry operations of the crystal are searched. Then they are compared with the crystallographic database and the space group type is determined.  The result is returned as the Dataset structure as a dataset.\n\nThe detail of the dataset is given at Dataset.\n\nDataset corresponding to the space group type in the standard setting is obtained by get_dataset. Here the standard setting means the first top one among the Hall symbols listed for each space group type. For example, H setting (hexagonal lattice) is chosen for rhombohedral crystals. get_dataset_with_hall_number explained below is used to choose different settings such as R setting of rhombohedral crystals. In this function, the other crystallographic setting is not obtained.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_error_code-Tuple{}","page":"Public API","title":"Spglib.get_error_code","text":"get_error_code()\n\nReturn an instance of the enumerated type SpglibReturnCode.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Spglib.get_error_message-Tuple{Spglib.SpglibReturnCode}","page":"Public API","title":"Spglib.get_error_message","text":"get_error_message(code::SpglibReturnCode)\n\nGet the corresponding error message for a given error code.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Spglib.get_hall_number_from_symmetry","page":"Public API","title":"Spglib.get_hall_number_from_symmetry","text":"get_hall_number_from_symmetry(rotations, translations, symprec=1e-5)\n\nReturn one Hall number corresponding to a space group of the given set of symmetry operations.\n\nWhen multiple Hall numbers exist for the space group, the smallest one (the first description of the space-group type in International Tables for Crystallography) is chosen.\n\nThis is expected to work well for the set of symmetry operations whose distortion is small. The aim of making this feature is to find space-group-type for the set of symmetry operations given by the other source than Spglib.\n\nNote that the definition of symprec is different from usual one, but is given in the fractional coordinates and so it should be small like 1e-5.\n\nwarning: Warning\nThis function will be replaced by get_spacegroup_type_from_symmetry.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_international","page":"Public API","title":"Spglib.get_international","text":"get_international(cell::AbstractCell, symprec=1e-5)\n\nReturn the space group type in Hermannâ€“Mauguin (international) notation.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_ir_reciprocal_mesh","page":"Public API","title":"Spglib.get_ir_reciprocal_mesh","text":"get_ir_reciprocal_mesh(cell::AbstractCell, mesh, symprec=1e-5; is_shift=falses(3), is_time_reversal=true)\n\nSearch irreducible reciprocal grid points from uniform mesh grid points specified by mesh and is_shift.\n\nReciprocal primitive vectors are divided by the number stored in mesh with (0 0 0)-centering. The center of grid mesh is shifted half of a grid spacing along corresponding reciprocal axis by setting 1 or true to each is_shift element. If 0 or false is set to each is_shift element, there is no shift. This limitation of shifting enables the irreducible k-point search significantly faster when the mesh is very dense.\n\nArguments\n\ncell: the input cell.\nmesh: the mesh numbers along each reciprocal axis. It is given by three integers.\nsymprec: the tolerance for symmetry search.\nis_shift: a 3-Boolean vector. When is_shift is set for each reciprocal primitive axis, the mesh is shifted along the axis in half of adjacent mesh points irrespective of the mesh numbers.\nis_time_reversal: whether to impose the time reversal symmetry.\n\nSee also BrillouinZoneMesh.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_magnetic_dataset","page":"Public API","title":"Spglib.get_magnetic_dataset","text":"get_magnetic_dataset(cell::SpglibCell, symprec=1e-5)\n\nReturn magnetic symmetry operations and standardized structure of given structure with site tensors.\n\nThe description of returned dataset is given at Magnetic dataset (experimental).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_magnetic_spacegroup_type-Tuple{Any}","page":"Public API","title":"Spglib.get_magnetic_spacegroup_type","text":"get_magnetic_spacegroup_type(uni_number)\n\nAccesses magnetic space-group type by serial number (from 1 to 1651) of UNI (or BNS) symbols.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Spglib.get_magnetic_spacegroup_type_from_symmetry","page":"Public API","title":"Spglib.get_magnetic_spacegroup_type_from_symmetry","text":"get_magnetic_spacegroup_type_from_symmetry(rotations, translations, time_reversals, lattice::Lattice, symprec=1e-5)\n\nDetermine magnetic space-group type from magnetic symmetry operations.\n\ntime_reversals takes false for ordinary operations and true for time-reversal operations.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_magnetic_symmetry_from_database","page":"Public API","title":"Spglib.get_magnetic_symmetry_from_database","text":"get_magnetic_symmetry_from_database(uni_number, hall_number=0)\n\nAccesses magnetic space-group operations in the built-in database using UNI number (from 1 to 1651).\n\nOptionally alternative settings can be specified with hallnumber. For type-I, type-II, and type-III magnetic space groups, `hallnumberchanges settings in family space group. For type-IV,hallnumberchanges settings in maximal space group. Whenhallnumber=0, the smallest hall number corresponding touni_number` is used.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_multiplicity","page":"Public API","title":"Spglib.get_multiplicity","text":"get_multiplicity(cell::AbstractCell, symprec=1e-5)\n\nReturn the exact number of symmetry operations.\n\nAn error is thrown when it fails.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_schoenflies","page":"Public API","title":"Spglib.get_schoenflies","text":"get_schoenflies(cell::AbstractCell, symprec=1e-5)\n\nReturn the space group type in Schoenflies notation.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_spacegroup_type-Tuple{Any}","page":"Public API","title":"Spglib.get_spacegroup_type","text":"get_spacegroup_type(hall_number)\n\nTranslate Hall number to space group information.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Spglib.get_spacegroup_type_from_symmetry","page":"Public API","title":"Spglib.get_spacegroup_type_from_symmetry","text":"get_spacegroup_type_from_symmetry(rotations, translations, lattice::Lattice, symprec=1e-5)\n\nReturn space-group type information from symmetry operations.\n\nThis is the replacement of get_hall_number_from_symmetry.\n\nThis is expected to work well for the set of symmetry operations whose distortion is small. The aim of making this feature is to find space-group-type for the set of symmetry operations given by the other source than Spglib.\n\nThe SpacegroupType structure is explained at SpacegroupType. The parameter lattice is used as the distance measure for symprec. If it is unknown, the following may be a reasonable choice:\n\njulia> lattice = Lattice([\n           1 0 0\n           0 1 0\n           0 0 1\n       ]);\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_stabilized_reciprocal_mesh","page":"Public API","title":"Spglib.get_stabilized_reciprocal_mesh","text":"get_stabilized_reciprocal_mesh(rotations, mesh, qpoints=[[0, 0, 0]]; is_shift=falses(3), is_time_reversal=true)\n\nSearch irreducible k-points from unique k-point mesh grids from direct (real space) basis vectors and a set of rotation parts of symmetry operations in direct space with one or multiple stabilizers.\n\nThe stabilizers are written in fractional coordinates. This function can be used to obtain all mesh grid points by setting rotations = [[1 0 0; 0 1 0; 0 0 1]], and qpoints = [[0, 0, 0]].\n\nSee also BrillouinZoneMesh.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_symmetry","page":"Public API","title":"Spglib.get_symmetry","text":"get_symmetry(cell::AbstractCell, symprec=1e-5)\n\nReturn the symmetry operations (rotations, translations) of a cell.\n\nReturned value rotations is a Vector of matrices. It has the length of \"number of symmetry operations\". Each matrix is a 3 times 3 integer matrix. Returned value translations is a Vector of vectors. It has the length of \"number of symmetry operations\". Each vector is a length-3 vector of floating point numbers.\n\nThe orders of the rotation matrices and the translation vectors correspond with each other, e.g., the second symmetry operation is organized by the set of the second rotation matrix and second translation vector in the respective arrays. Therefore a set of symmetry operations may obtained by [(r, t) for r, t in zip(rotations, translations)].\n\nThe operations are given with respect to the fractional coordinates (not for Cartesian coordinates). The rotation matrix mathbfW and translation vector textw are used as follows:\n\ntildemathbfx_3times 1 = mathbfW_3times 3 mathbfx_3times 1 + textw_3times 1\n\nThe three values in the vector are given for the a, b, and c axes, respectively.\n\nAs an exceptional case, if a supercell (or non-primitive cell) has the basis vectors whose lattice breaks crystallographic point group, the crystallographic symmetry operations are searched within this broken symmetry, i.e., at most the crystallographic point group found in this case is the point group of the lattice. For example, this happens for the 2times 1times 1 supercell of a conventional cubic unit cell. This may not be understandable in crystallographic sense, but is practically useful treatment for research in computational materials science.\n\nExamples\n\njulia> lattice = Lattice([\n           [5.0759761474456697, 5.0759761474456697, 0],\n           [-2.8280307701821314, 2.8280307701821314, 0],\n           [0, 0, 8.57154746],\n       ]);\n\njulia> positions = [\n           [0.0, 0.84688439, 0.1203133],\n           [0.0, 0.65311561, 0.6203133],\n           [0.0, 0.34688439, 0.3796867],\n           [0.0, 0.15311561, 0.8796867],\n           [0.5, 0.34688439, 0.1203133],\n           [0.5, 0.15311561, 0.6203133],\n           [0.5, 0.84688439, 0.3796867],\n           [0.5, 0.65311561, 0.8796867],\n       ];\n\njulia> atoms = fill(35, length(positions));\n\njulia> cell = SpglibCell(lattice, positions, atoms);\n\njulia> rotations, translations = get_symmetry(cell);\n\njulia> size(rotations) == size(translations) == (16,)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_symmetry_from_database-Tuple{Any}","page":"Public API","title":"Spglib.get_symmetry_from_database","text":"get_symmetry_from_database(hall_number)\n\nReturn the symmetry operations given a hall_number.\n\nThis function allows to directly access to the space group operations in the spglib database. To specify the space group type with a specific choice, hall_number is used.\n\nThe definition of hall_number is found at Space group type.\n\nThe serial number from 1 to 530 which are found at list of space groups (Seto's web site). Be sure that this is not a standard crystallographic definition.\n\nExamples\n\njulia> get_symmetry_from_database(304);\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Spglib.get_symmetry_with_collinear_spin","page":"Public API","title":"Spglib.get_symmetry_with_collinear_spin","text":"get_symmetry_with_collinear_spin(cell::SpglibCell, symprec=1e-5)\n\nFind symmetry operations with collinear polarizations (spins) on atoms.\n\nExcept for the magmoms in the cell, the usage is basically the same as get_symmetry. But as an output, equivalent_atoms are obtained as the last returned value. The size of this array is the same of number of atoms in the cell.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_symmetry_with_site_tensors","page":"Public API","title":"Spglib.get_symmetry_with_site_tensors","text":"get_symmetry_with_site_tensors(cell::SpglibCell, symprec=1e-5; with_time_reversal=true)\n\nReturn magnetic symmetry operations represented by rotation, translation, and spin_flips.\n\nReturned spin_flips represents sign of site tensors after applying time-reversal operations: 1 for non time reversal, and -1 for time reversal.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.get_version-Tuple{}","page":"Public API","title":"Spglib.get_version","text":"get_version()\n\nObtain the version number of spglib.\n\nThis is the mergence of spg_get_major_version, spg_get_minor_version, and spg_get_micro_version in its C-API.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Spglib.is_spin_collinear-Tuple{SpglibCell}","page":"Public API","title":"Spglib.is_spin_collinear","text":"is_spin_collinear(cell::SpglibCell)\n\nCheck if the spins (magmoms) in the given cell are collinear.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Spglib.niggli_reduce","page":"Public API","title":"Spglib.niggli_reduce","text":"niggli_reduce(lattice::AbstractMatrix, symprec=1e-5)\nniggli_reduce(cell::Cell, symprec=1e-5)\n\nApply Niggli reduction to input basis vectors lattice.\n\nThe transformation from original basis vectors  beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix to final basis vectors beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix is achieved by linear combination of basis vectors with integer coefficients without rotating coordinates. Therefore the transformation matrix is obtained by\n\nmathbfP = beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix^-1\n\nand the matrix elements have to be almost integers.\n\nSee also Computing rigid rotation introduced by idealization.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.refine_cell","page":"Public API","title":"Spglib.refine_cell","text":"refine_cell(cell::AbstractCell, symprec=1e-5)\n\nReturn the refined cell.\n\nThis function is now a shortcut of standardize_cell with to_primitive=false and no_idealize=false.\n\nThe standardized crystal structure is obtained from a non-standard crystal structure which may be slightly distorted within a symmetry recognition tolerance, or whose primitive vectors are differently chosen, etc.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Spglib.standardize_cell","page":"Public API","title":"Spglib.standardize_cell","text":"standardize_cell(cell::AbstractCell, symprec=1e-5; to_primitive=false, no_idealize=false)\n\nReturn the standardized cell.\n\nThe standardized unit cell (see Spglib conventions of standardized unit cell) is generated from an input unit cell structure and its symmetry found by the symmetry search. The choice of the setting for each space group type is as explained for get_dataset. Usually to_primitive=false and no_idealize=false are recommended to set and this setting results in the same behavior as spg_refine_cell.\n\nThe standardized unit cell is generated from an input unit cell structure and its symmetry found by the symmetry search. The choice of the setting for each space group type is as explained for get_dataset.\n\nArguments\n\ncell: the input cell to standardize.\nsymprec: the tolerance for symmetry search.\nto_primitive=true is used to create the standardized primitive cell with the transformation matrices shown at Transformation to the primitive cell, otherwise to_primitive=false must be specified.\nno_idealize=false is used to idealize the lengths and angles of basis vectors with adjusting the positions of atoms to nearest exact positions according to crystal symmetry. However the crystal can be rotated in Cartesian coordinates by the idealization of the basis vectors. no_idealize=true disables this. The detail of the idealization (no_idealize=false) is written at Idealization of unit cell structure. no_idealize=true may be useful when we want to leave basis vectors and atomic positions in Cartesian coordinates fixed.\n\n\n\n\n\n","category":"function"},{"location":"man/troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"Pages = [\"troubleshooting.md\"]\nDepth = 2:2\n\nThis page collects some possible errors you may encounter along with tips on how to fix them. If you have some questions about how to use this code, you are welcome to discuss with us.\n\nIf you have additional tips, please either report an issue or submit a pull request with suggestions.","category":"section"},{"location":"man/troubleshooting/#Cannot-find-the-Julia-executable","page":"Troubleshooting","title":"Cannot find the Julia executable","text":"Make sure you have Julia installed in your environment. Please download the latest stable version for your platform. If you are using a *nix system, the recommended way is to use Juliaup. If you do not want to install Juliaup or you are using other platforms that Julia supports, download the corresponding binaries. Then, create a symbolic link to the Julia executable. If the path is not in your $PATH environment variable, export it to your $PATH.\n\nSome clusters, like Comet, or Expanse, already have Julia installed as a module, you may just module load julia to use it. If not, either install by yourself or contact your administrator.\n\nSee Installation Guide for more information.","category":"section"},{"location":"man/troubleshooting/#Julia-starts-slow","page":"Troubleshooting","title":"Julia starts slow","text":"First, we recommend you download the latest version of Julia. Usually, the newest version has the best performance.\n\nIf you need to use Julia for a simple, one-time task, you can start the Julia REPL with\n\njulia --compile=min\n\nto minimize compilation or\n\njulia --optimize=0\n\nto minimize optimizations, or just use both. Or you could make a system image and run with\n\njulia --sysimage custom-image.so\n\nSee Fredrik Ekre's talk for details.","category":"section"},{"location":"man/troubleshooting/#Unable-to-install-the-package","page":"Troubleshooting","title":"Unable to install the package","text":"First, verify if your platform is supported by referring to the spglib_jll.jl platforms. If it's not supported, kindly report the issue to the developers here.\n\nIf you can install spglib_jll.jl but encounter issues with Spglib.jl, please report to the developer here.","category":"section"},{"location":"man/troubleshooting/#Returned-cell-symmetry-is-wrong","page":"Troubleshooting","title":"Returned cell symmetry is wrong","text":"Check whether you set the lattice correctly. This is the part where errors can easily occur, as we adopt a different convention from the Python and C versions.\n\nFor example, the example shown in Spglib's official documentation is written as follows:\n\n#include <assert.h>\n#include \"spglib.h\"\n\nint main(void) {\n    SpglibDataset *dataset;\n    // Wurtzite structure (P6_3mc)\n    double lattice[3][3] = {\n        {3.111, -1.5555, 0}, {0, 2.6942050311733885, 0}, {0, 0, 4.988}};\n    double position[4][3] = {\n        {1.0 / 3, 2.0 / 3, 0.0},\n        {2.0 / 3, 1.0 / 3, 0.5},\n        {1.0 / 3, 2.0 / 3, 0.6181},\n        {2.0 / 3, 1.0 / 3, 0.1181},\n    };\n    int types[4] = {1, 1, 2, 2};\n    int num_atom = 4;\n    double symprec = 1e-5;\n    dataset = spg_get_dataset(lattice, position, types, num_atom, symprec);\n    assert(dataset->spacegroup_number == 186);\n    spg_free_dataset(dataset);\n}\n\nThus, the Python correspondence of the code should be:\n\nimport spglib\n\nlattice = [[3.111, 0, 0], [-1.5555, 2.6942050311733885, 0], [0, 0, 4.988]]\nposition = [\n    [1.0 / 3, 2.0 / 3, 0.0],\n    [2.0 / 3, 1.0 / 3, 0.5],\n    [1.0 / 3, 2.0 / 3, 0.6181],\n    [2.0 / 3, 1.0 / 3, 0.1181],\n]\ntypes = [1, 1, 2, 2]\nsymprec = 1e-5\ncell = (lattice, positions, types)\ndataset = spglib.get_symmetry_dataset(cell, symprec=symprec)\nassert dataset['number'] == 186\n\nNote that in Python, the lattice is transposed, as explained in its official documentation.\n\nHowever, the corresponding code in Julia should be written as follows:\n\nusing Spglib\nlattice = [[3.111, 0, 0], [-1.5555, 2.6942050311733885, 0], [0, 0, 4.988]];\npositions = [\n    [1.0 / 3, 2.0 / 3, 0.0],\n    [2.0 / 3, 1.0 / 3, 0.5],\n    [1.0 / 3, 2.0 / 3, 0.6181],\n    [2.0 / 3, 1.0 / 3, 0.1181],\n];\natoms = [1, 1, 2, 2];\ncell = Cell(lattice, positions, atoms)\ndataset = get_dataset(cell, 1e-5)\ndataset.spacegroup_number\n\nAlthough the Julia definition of our Basis vectors is not transposed (like the C-API), when written one by one, it still resembles a transposed version of the lattice in C. However, they both represent the following matrix:\n\nbeginbmatrix\n    3111  -15555  0 \n    0  26942050311733885  0 \n    0  0  4988\nendbmatrix\n\nOf course, you can construct the lattice directly using its matrix form:\n\nlattice = [\n    3.111  -1.5555  0.0\n    0.0  2.6942050311733885  0.0\n    0.0  0.0  4.988\n];\n\nIf you are not careful when writing these matrices, you may encounter unexpected results:\n\nimport spglib\n\nlattice = [\n    [3.111, -1.5555, 0],\n    [0, 2.6942050311733885, 0],\n    [0, 0, 4.988]\n]\npositions = [\n    [1.0 / 3, 2.0 / 3, 0.0],\n    [2.0 / 3, 1.0 / 3, 0.5],\n    [1.0 / 3, 2.0 / 3, 0.6181],\n    [2.0 / 3, 1.0 / 3, 0.1181]\n]\ntypes = [1, 1, 2, 2]\nnum_atom = 4\nsymprec = 1e-5\ncell = (lattice, positions, types)\ndataset = spglib.get_symmetry_dataset(cell, symprec=symprec)\n\n>>> dataset['number']\n4\n>>> dataset['international']\n'P2_1'\n\nOr this:\n\nlattice = [[3.111, -1.5555, 0], [0, 2.6942050311733885, 0], [0, 0, 4.988]];\ncell = Cell(lattice, positions, atoms)\ndataset = get_dataset(cell, 1e-5)\ndataset.spacegroup_number\ndataset.international_symbol","category":"section"},{"location":"man/troubleshooting/#Julia's-results-are-different-from-Python's","page":"Troubleshooting","title":"Julia's results are different from Python's","text":"For the same reason, the returned results from Python, especially lattices, are transposed versions of those in Julia.\n\n>>> dataset['primitive_lattice']\narray([[ 3.111     ,  0.        ,  0.        ],\n       [-1.5555    ,  2.69420503,  0.        ],\n       [ 0.        ,  0.        ,  4.988     ]])\n>>> dataset['std_lattice']\narray([[ 3.111     ,  0.        ,  0.        ],\n       [-1.5555    ,  2.69420503,  0.        ],\n       [ 0.        ,  0.        ,  4.988     ]])\n>>> std_lattice_before_idealization = np.dot(\n        np.transpose(lattice),\n        np.linalg.inv(dataset['transformation_matrix'])\n    ).T\narray([[ 3.111     ,  0.        ,  0.        ],\n       [-1.5555    ,  2.69420503,  0.        ],\n       [ 0.        ,  0.        ,  4.988     ]])\n\nThese are equivalent to the following Julia matrices:\n\n[\n    3.111   0.0      0.0\n    -1.5555  2.69421  0.0\n    0.0     0.0      4.988\n];\n[\n    3.111   0.0      0.0\n    -1.5555  2.69421  0.0\n    0.0     0.0      4.988\n];\n[\n    3.111   0.0      0.0\n    -1.5555  2.69421  0.0\n    0.0     0.0      4.988\n];\n\nHowever, the actual Julia results should be:\n\nusing Spglib\nlattice = [[3.111, 0, 0], [-1.5555, 2.6942050311733885, 0], [0, 0, 4.988]];\npositions = [\n    [1.0 / 3, 2.0 / 3, 0.0],\n    [2.0 / 3, 1.0 / 3, 0.5],\n    [1.0 / 3, 2.0 / 3, 0.6181],\n    [2.0 / 3, 1.0 / 3, 0.1181],\n];\natoms = [1, 1, 2, 2];\ncell = Cell(lattice, positions, atoms)\ndataset = get_dataset(cell, 1e-5)\ndataset.primitive_lattice\ndataset.std_lattice\nstd_lattice_before_idealization =\n    convert(Matrix{Float64}, Lattice(cell)) * inv(dataset.transformation_matrix)","category":"section"},{"location":"man/troubleshooting/#Upgrading-from-v0.9-to-v1.0","page":"Troubleshooting","title":"Upgrading from v0.9+ to v1.0+","text":"Spglib.jl relies on a JLL package wrapper (spglib_jll.jl).\n\nUp to v0.9, Spglib.jl used spglib_jll.jl v2.1.0.\nStarting with v1.0, it uses spglib_jll.jl v2.2+.\n\nBetween v2.1 and v2.2, spglib introduced some changes (see the official release notes). As a result, code that worked with Spglib.jl v0.9+ may behave differently when upgraded to v1.0+.\n\nThe API itself has not changed, but some returned values may differ.\n\nPlease be aware of these differences. If you have already updated your code but still observe results that differ between the Julia API and the C/Python APIs, let me know so I can investigate.","category":"section"},{"location":"man/definitions/#Definitions-and-conventions","page":"Definitions and conventions","title":"Definitions and conventions","text":"Pages = [\"definitions.md\"]\nDepth = 2:3\n\nwarning: Warning\nOur definitions and conventions are mostly adapted from here, with some minor differences, such as the matrix representation of lattices.","category":"section"},{"location":"man/definitions/#Basis-vectors","page":"Definitions and conventions","title":"Basis vectors","text":"In this package, basis vectors are represented by three-column vectors:\n\nmathbfa = beginbmatrix\n    a_x \n    a_y \n    a_z\nendbmatrix\nquad\nmathbfb = beginbmatrix\n    b_x \n    b_y \n    b_z\nendbmatrix\nquad\nmathbfc = beginbmatrix\n    c_x \n    c_y \n    c_z\nendbmatrix\n\nin Cartesian coordinates.\n\nTherefore, a lattice is represented as\n\nmathbfA =\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix =\nbeginbmatrix\n    a_x  b_x  c_x \n    a_y  b_y  c_y \n    a_z  b_z  c_z\nendbmatrix\n\nDepending on the situation, beginbmatrix mathbfa_1  mathbfa_2  mathbfa_3 endbmatrix is used instead of beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix.\n\nA reciprocal lattice is its inverse, represented as three columns vectors, too:\n\nmathbfB =\nbigl(mathbfA^-1bigr)^intercal =\nbeginbmatrix mathbfb_1  mathbfb_2  mathbfb_3 endbmatrix\n\nso that\n\nmathbfA mathbfB^intercal = mathbfB^intercal mathbfA = mathbfI\n\nwhere mathbfI is the 3 times 3 identity matrix.\n\nWe choose this convention because it is convenient for converting reduced reciprocal coordinates mathbfx^ast to Cartesian coordinates using the expression mathbfB mathbfx^ast.\n\nThis is analogous to the convention employed in Atomic point coordinates for the definition of reduced coordinates.\n\nnote: Note\nIn crystallography, the convention used is mathbfa_i cdot mathbfb_j = delta_ij, where delta_ij is the Kronecker delta. This is in contrast to the solid-state physics convention, which is mathbfa_i cdot mathbfb_j = 2pidelta_ij.","category":"section"},{"location":"man/definitions/#Atomic-point-coordinates","page":"Definitions and conventions","title":"Atomic point coordinates","text":"Coordinates of an atomic point mathbfx are represented as three fractional values relative to basis vectors as follows,\n\nmathbfx = beginbmatrix\n    x_1 \n    x_2 \n    x_3\nendbmatrix\n\nwhere 0 le x_i  1. A position vector mathbfr in Cartesian coordinates is obtained by\n\nmathbfr = mathbfA mathbfx =\nbeginbmatrix mathbfa_1  mathbfa_2  mathbfa_3 endbmatrix\nbeginbmatrix\n    x_1 \n    x_2 \n    x_3\nendbmatrix\n\nor\n\nmathbfr = sum_i x_i mathbfa_i\n\nnote: Note\nIn the Python version of Spglib, lattice parameters lattice are given by a 3times 3 matrix with floating point values, where mathbfa, mathbfb, mathbfc are given as rows, which results in the transpose of the definition for C-API. That is, in Python, the basis vectors are written as follows:[ [ a_x, b_x, c_x ],\n  [ a_y, b_y, c_y ],\n  [ a_z, b_z, c_z ] ]Here, we adopt the C-API convention, i.e., writing basis vectors as columns.","category":"section"},{"location":"man/definitions/#Space-group-operation-and-change-of-basis","page":"Definitions and conventions","title":"Space group operation and change of basis","text":"","category":"section"},{"location":"man/definitions/#Symmetry-operation-(\\mathbf{W},-\\mathbf{w})","page":"Definitions and conventions","title":"Symmetry operation (mathbfW mathbfw)","text":"A symmetry operation consists of a pair of the rotation part mathbfW and translation part mathbfw, and is represented as (mathbfW mathbfw). The symmetry operation transfers mathbfx to tildemathbfx as follows:\n\ntildemathbfx = mathbfW mathbfx + mathbfw","category":"section"},{"location":"man/definitions/#Transformation-matrix-\\mathbf{P}-and-origin-shift-\\mathbf{p}","page":"Definitions and conventions","title":"Transformation matrix mathbfP and origin shift mathbfp","text":"The transformation matrix mathbfP changes choice of basis vectors as follows\n\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix =\nbeginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix\nmathbfP\n\nwhere beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix and beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix are the basis vectors of an arbitrary system and of a standardized system, respectively. In general, the transformation matrix is not limited for the transformation from the standardized system, but can be used in between any systems possibly transformed. It has to be emphasized that the transformation matrix does not rotate a crystal in Cartesian coordinates, but just changes the choices of basis vectors.","category":"section"},{"location":"man/definitions/#Difference-between-rotation-and-transformation-matrices","page":"Definitions and conventions","title":"Difference between rotation and transformation matrices","text":"A rotation matrix rotates (or mirrors, inverts) the crystal body with respect to origin. A transformation matrix changes the choice of the basis vectors, but does not rotate the crystal body.","category":"section"},{"location":"man/definitions/#Active/reverse/alibi-transformation","page":"Definitions and conventions","title":"Active/reverse/alibi transformation","text":"A space group operation having no translation part sends an atom to another point by\n\ntildemathbfx = mathbfW mathbfx\n\nwhere tildemathbfx and mathbfx are represented with respect to the same basis vectors beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix. Equivalently the rotation is achieved by rotating the basis vectors:\n\nbeginbmatrix tildemathbfa  tildemathbfb  tildemathbfc endbmatrix =\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfW\n\nwith keeping the representation of the atomic point coordinates mathbfx because\n\ntildemathbfx = beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix\ntildemathbfx =\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfW mathbfx =\nbeginbmatrix tildemathbfa  tildemathbfb  tildemathbfc endbmatrix\nmathbfx","category":"section"},{"location":"man/definitions/#Passive/forward/alias-transformation","page":"Definitions and conventions","title":"Passive/forward/alias transformation","text":"The transformation matrix changes the choice of the basis vectors as:\n\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix =\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfP\n\nThe atomic position vector is not altered by this transformation, i.e.,\n\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfx =\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfx\n\nHowever the representation of the atomic point coordinates changes as follows:\n\nmathbfP mathbfx = mathbfx\n\nbecause\n\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfP mathbfx =\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfx =\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfx","category":"section"},{"location":"man/definitions/#Spglib-conventions-of-standardized-unit-cell","page":"Definitions and conventions","title":"Spglib conventions of standardized unit cell","text":"","category":"section"},{"location":"man/definitions/#Transformation-to-the-primitive-cell","page":"Definitions and conventions","title":"Transformation to the primitive cell","text":"In the standardized unit cells, there are five different centring types available, base centerings of A and C, rhombohedral (R), body-centred (I), and face-centred (F). The transformation is applied to the standardized unit cell by\n\nbeginbmatrix mathbfa_textp  mathbfb_textp  mathbfc_textp endbmatrix =\nbeginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix\nmathbfP\n\nwhere mathbfa_textp, mathbfb_textp, and mathbfc_textp are the basis vectors of the primitive cell and mathbfP is the transformation matrix from the standardized unit cell to the primitive cell. Matrices mathbfP for different centring types are given as follows:\n\nmathbfP_textA = beginbmatrix\n    1  0  0 \n    0  dfrac12  dfrac-12 \n    0  dfrac12  dfrac12\nendbmatrix\nquad\nmathbfP_textC = beginbmatrix\n    dfrac12  dfrac12  0 \n    dfrac-12  dfrac12  0 \n    0  0  1\nendbmatrix\nquad\nmathbfP_textR = beginbmatrix\n    dfrac23  dfrac-13  dfrac-13 \n    dfrac13  dfrac13  dfracbar23 \n    dfrac13  dfrac13  dfrac13\nendbmatrix\nquad\nmathbfP_textI = beginbmatrix\n    dfrac-12  dfrac12  dfrac12 \n    dfrac12  dfrac-12  dfrac12 \n    dfrac12  dfrac12  dfrac-12\nendbmatrix\nquad\nmathbfP_textF = beginbmatrix\n    0  dfrac12  dfrac12 \n    dfrac12  0  dfrac12 \n    dfrac12  dfrac12  0\nendbmatrix\n\nThe choice of transformation matrix depends on the purpose.\n\nFor rhombohedral lattice systems with the H setting (hexagonal lattice), mathbfP_textR is applied to obtain primitive basis vectors. However, with the R setting (rhombohedral lattice), no transformation matrix is used because it is already a primitive cell.","category":"section"},{"location":"man/definitions/#idealization","page":"Definitions and conventions","title":"Idealization of unit cell structure","text":"Spglib allows tolerance parameters to match a slightly distorted unit cell structure to a space group type with some higher symmetry. Using obtained symmetry operations, the distortion is removed to idealize the unit cell structure. The coordinates of atomic points are idealized using respective site-symmetries[1]. The basis vectors are idealized by forcing them into respective lattice shapes as follows. In this treatment, except for triclinic crystals, crystals can be rotated in Cartesian coordinates, which is the different type of transformation from that of the change-of-basis transformation explained above.","category":"section"},{"location":"man/definitions/#Triclinic-lattice","page":"Definitions and conventions","title":"Triclinic lattice","text":"Niggli-reduced cell is used for choosing mathbfa, mathbfb, and mathbfc.\nmathbfa is set along +x direction of Cartesian coordinates.\nmathbfb is set in x-y plane of Cartesian coordinates so that mathbfatimesmathbfb is along +z direction of Cartesian coordinates.","category":"section"},{"location":"man/definitions/#Monoclinic-lattice","page":"Definitions and conventions","title":"Monoclinic lattice","text":"The b-axis is taken as the unique axis.\nalpha = 90^circ and gamma = 90^circ, while 90^circ  beta  120^circ.\nmathbfa is set along +x direction of Cartesian coordinates.\nmathbfb is set along +y direction of Cartesian coordinates.\nmathbfc is set in x-z plane of Cartesian coordinates.","category":"section"},{"location":"man/definitions/#Orthorhombic-lattice","page":"Definitions and conventions","title":"Orthorhombic lattice","text":"alpha = beta = gamma = 90^circ.\nmathbfa is set along +x direction of Cartesian coordinates.\nmathbfb is set along +y direction of Cartesian coordinates.\nmathbfc is set along +z direction of Cartesian coordinates.","category":"section"},{"location":"man/definitions/#Tetragonal-lattice","page":"Definitions and conventions","title":"Tetragonal lattice","text":"alpha = beta = gamma = 90^circ.\na=b.\nmathbfa is set along +x direction of Cartesian coordinates.\nmathbfb is set along +y direction of Cartesian coordinates.\nmathbfc is set along +z direction of Cartesian coordinates.","category":"section"},{"location":"man/definitions/#Rhombohedral-lattice","page":"Definitions and conventions","title":"Rhombohedral lattice","text":"alpha = beta = gamma.\na=b=c.\nLet mathbfa, mathbfb, and mathbfc projected on x-y plane in Cartesian coordinates be mathbfa_xy, mathbfb_xy, and mathbfc_xy, respectively, and their angles be alpha_xy, beta_xy, gamma_xy, respectively.\nLet mathbfa, mathbfb, and mathbfc projected along z-axis in Cartesian coordinates be mathbfa_z, mathbfb_z, and mathbfc_z, respectively.\nmathbfa_xy is set along the ray 30^circ rotated counter-clockwise from the +x direction of Cartesian coordinates, and mathbfb_xy and mathbfc_xy are placed by angles 120^circ and 240^circ from mathbfa_xy counter-clockwise, respectively.\nalpha_xy = beta_xy = gamma_xy = 120^circ.\na_xy = b_xy = c_xy.\na_z = b_z = c_z.","category":"section"},{"location":"man/definitions/#Hexagonal-lattice","page":"Definitions and conventions","title":"Hexagonal lattice","text":"alpha = beta = 90^circ, gamma = 120^circ.\na=b.\nmathbfa is set along +x direction of Cartesian coordinates.\nmathbfb is set in x-y plane of Cartesian coordinates.\nmathbfc is set along +z direction of Cartesian coordinates.","category":"section"},{"location":"man/definitions/#Cubic-lattice","page":"Definitions and conventions","title":"Cubic lattice","text":"alpha = beta = gamma = 90^circ.\na=b=c.\nmathbfa is set along +x direction of Cartesian coordinates.\nmathbfb is set along +y direction of Cartesian coordinates.\nmathbfc is set along +z direction of Cartesian coordinates.","category":"section"},{"location":"man/definitions/#Rotation-introduced-by-idealization","page":"Definitions and conventions","title":"Rotation introduced by idealization","text":"In the idealization step presented above, the input unit cell crystal structure can be rotated in the Cartesian coordinates. The rotation matrix mathbfR of this rotation is defined by\n\nbeginbmatrix barmathbfa_texts  barmathbfb_texts  barmathbfc_texts endbmatrix =\nmathbfR beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix\n\nThis rotation matrix rotates the standardized crystal structure before idealization beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix to that after idealization beginbmatrix barmathbfa_texts  barmathbfb_texts  barmathbfc_texts endbmatrix in Cartesian coordinates of the given input unit cell.\n\n[1]: Grosse-Kunstleve, R. W. & Adams, P. D. (2002). Acta Crystallogr A Found Crystallogr 58, 60â€“65.","category":"section"},{"location":"developers/style-guide/#Style-Guide","page":"Style Guide","title":"Style Guide","text":"Pages = [\"style-guide.md\"]\nDepth = 2:3\n\nThis section describes the coding style rules that apply to our code and that we recommend you to use it also.\n\nIn some cases, our style guide diverges from Julia's official Style Guide (Please read it!). All such cases will be explicitly noted and justified.\n\nOur style guide adopts many recommendations from the BlueStyle. Please read the BlueStyle before contributing to this package. If these guidelines are not followed, your pull requests may not be accepted.\n\ninfo: Info\nThe style guide is always a work in progress, and not all Spglib code follows the rules. When modifying Spglib, please fix the style violations of the surrounding code (i.e., leave the code tidier than when you started). If large changes are needed, consider separating them into another pull request.","category":"section"},{"location":"developers/style-guide/#Formatting","page":"Style Guide","title":"Formatting","text":"","category":"section"},{"location":"developers/style-guide/#Run-JuliaFormatter","page":"Style Guide","title":"Run JuliaFormatter","text":"Spglib uses JuliaFormatter as an auto-formatting tool.\n\nWe use the options contained in .JuliaFormatter.toml.\n\nTo format your code, cd to the Spglib directory, then run:\n\njulia> using Pkg\n\njulia> Pkg.add(\"JuliaFormatter\")\n\njulia> using JuliaFormatter: format\n\njulia> format(\"docs\"); format(\"src\"); format(\"test\")\n\ninfo: Info\nA continuous integration check verifies that all PRs made to Spglib have passed the formatter.\n\nThe following sections outline extra style guide points that are not fixed automatically by JuliaFormatter.","category":"section"},{"location":"developers/style-guide/#Use-the-Julia-extension-for-Visual-Studio-Code","page":"Style Guide","title":"Use the Julia extension for Visual Studio Code","text":"Please use Visual Studio Code with the Julia extension to edit, format, and test your code. For the time being, we do not recommend using editors other than Visual Studio Code to edit your code.\n\nThis extension already has JuliaFormatter integrated. So to format your code, follow the steps listed here.","category":"section"},{"location":"man/installation/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"Pages = [\"installation.md\"]\nDepth = 2:3\n\nHere are the installation instructions for package Spglib. If you have trouble installing it, please refer to our Troubleshooting page for more information.","category":"section"},{"location":"man/installation/#Install-Julia","page":"Installation Guide","title":"Install Julia","text":"First, you should install Julia. We recommend downloading it from its official website. Please follow the detailed instructions on its website if you have to build Julia from source. Some computing centers provide preinstalled Julia. Please contact your administrator for more information in that case. Here's some additional information on how to set up Julia on HPC clusters.\n\nIf you have Homebrew installed, open the Terminal app and type\n\nbrew install julia\n\nto install it as a formula.\n\nIf you are also using macOS and want to install it as a prebuilt binary app, type\n\nbrew install --cask julia\n\ninstead.\n\nIf you want to install multiple Julia versions in the same operating system, a recommended way is to use a version manager such as Juliaup. First, install Juliaup. Then, run\n\njuliaup add release\njuliaup default release\n\nto configure the julia command to start the latest stable version of Julia (this is also the default value).\n\nHere is a short video introduction to Juliaup made by its authors.","category":"section"},{"location":"man/installation/#Which-version-should-I-pick?","page":"Installation Guide","title":"Which version should I pick?","text":"You can install the current stable release or the long-term support (LTS) release.\n\nThe current stable release is the latest release of Julia. It has access to newer features, and is likely faster.\nThe long-term support release is an older version of Julia that has continued to receive bug and security fixes. However, it may not have the latest features or performance improvements.\n\nFor most users, you should install the current stable release, and whenever Julia releases a new version of the current stable release, you should update your version of Julia. Note that any code you write on one version of the current stable release will continue to work on all subsequent releases.\n\nFor users in restricted software environments (e.g., your enterprise IT controls what software you can install), you may be better off installing the long-term support release because you will not have to update Julia as frequently.\n\nVersions above v1.3, especially the latest stable ones, are strongly recommended. This package is highly unlikely to work on v1.0 and earlier versions. Since the Julia team has set v1.6 as the LTS release, we will gradually drop support for versions below v1.6.\n\nJulia and Julia packages support multiple operating systems and CPU architectures; check this table to see if it can be installed on your machine. For Mac computers with M-series processors, this package and its dependencies may not work. Please install the Intel-compatible version of Julia (for macOS x86-64) if any platform-related error occurs.","category":"section"},{"location":"man/installation/#Install-the-package","page":"Installation Guide","title":"Install the package","text":"Now I am using macOS as a standard platform to explain the following steps:\n\nOpen the Terminal app, and type julia to start an interactive session (known as the REPL).\nRun the following commands and wait for them to finish:\njulia> using Pkg\n\njulia> Pkg.update()\n\njulia> Pkg.add(\"Spglib\")\nRun\njulia> using Spglib\nand have fun!\nPlease keep the Julia session active while using it. Restarting the session may take some time.\n\nIf you want to install the latest in-development (probably buggy) version of Spglib, type\n\nusing Pkg\nPkg.update()\npkg\"add https://github.com/singularitti/Spglib.jl\"\n\nin the second step above.","category":"section"},{"location":"man/installation/#Update-the-package","page":"Installation Guide","title":"Update the package","text":"Please watch our GitHub repository for new releases. Once we release a new version, you can update Spglib by typing\n\nusing Pkg\nPkg.update(\"Spglib\")\nPkg.gc()\n\nin the Julia REPL.","category":"section"},{"location":"man/installation/#Uninstall-and-then-reinstall-the-package","page":"Installation Guide","title":"Uninstall and then reinstall the package","text":"Sometimes errors may occur if the package is not properly installed. In this case, you may want to uninstall and reinstall the package. Here is how to do that:\n\nTo uninstall, in a Julia session, run\njulia> using Pkg\n\njulia> Pkg.rm(\"Spglib\")\n\njulia> Pkg.gc()\nPress Ctrl+D to quit the current session. Start a new Julia session and reinstall Spglib.","category":"section"},{"location":"lib/internals/reciprocal/#Brillouin-zone-meshes","page":"Brillouin zone meshes","title":"Brillouin zone meshes","text":"","category":"section"},{"location":"lib/internals/reciprocal/#Spglib.BrillouinZoneMesh","page":"Brillouin zone meshes","title":"Spglib.BrillouinZoneMesh","text":"BrillouinZoneMesh(mesh, is_shift, ir_mapping_table, grid_address)\n\nRepresent the Brillouin zone mesh for searching (irreducible) reciprocal grid points from uniform mesh grid points specified by mesh and is_shift.\n\nReciprocal primitive vectors are divided by the number stored in mesh with (0 0 0)-centering. The center of grid mesh is shifted half of a grid spacing along the corresponding reciprocal axis by setting 1 or true to each is_shift element. If 0 or false is set to each is_shift element, there is no shift. This limitation of shifting enables the irreducible k-point search to be significantly faster when the mesh is very dense.\n\nThe reducible uniform grid points are stored in fractional coordinates as grid_address. A map between reducible and irreducible points is stored as ir_mapping_table in the indices of grid_address.\n\nwarning: Warning\nThe mapping table's indices start from 1, not 0 as in Python or C.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/error/#Error","page":"Error","title":"Error","text":"","category":"section"},{"location":"lib/internals/error/#Spglib.SpglibReturnCode","page":"Error","title":"Spglib.SpglibReturnCode","text":"Represent various return codes from the Spglib library.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/error/#Spglib.get_error_code","page":"Error","title":"Spglib.get_error_code","text":"get_error_code()\n\nReturn an instance of the enumerated type SpglibReturnCode.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/error/#Spglib.get_error_message","page":"Error","title":"Spglib.get_error_message","text":"get_error_message(code::SpglibReturnCode)\n\nGet the corresponding error message for a given error code.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/error/#Spglib.check_error","page":"Error","title":"Spglib.check_error","text":"check_error()\n\nCheck if an error has occurred and throw an exception if so.\n\n\n\n\n\n","category":"function"},{"location":"developers/design-principles/#Design-Principles","page":"Design Principles","title":"Design Principles","text":"Pages = [\"design-principles.md\"]\nDepth = 2:2\n\nWe adopt some SciML design guidelines here. Please read them before contributing!","category":"section"},{"location":"developers/design-principles/#Consistency-vs-adherence","page":"Design Principles","title":"Consistency vs adherence","text":"According to PEP8:\n\nA style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important.However, know when to be inconsistentâ€”sometimes style guide recommendations just aren't applicable. When in doubt, use your best judgment. Look at other examples and decide what looks best. And donâ€™t hesitate to ask!","category":"section"},{"location":"developers/design-principles/#Community-contribution-guidelines","page":"Design Principles","title":"Community contribution guidelines","text":"For a comprehensive set of community contribution guidelines, refer to ColPrac. A relevant point to highlight is that one PR should do one thing. In the context of style, this means that PRs which update the style of a package's code should not be mixed with fundamental code contributions. This separation makes it easier to ensure that large style improvement are isolated from substantive (and potentially breaking) code changes.","category":"section"},{"location":"developers/design-principles/#Open-source-contributions-are-allowed-to-start-small-and-grow-over-time","page":"Design Principles","title":"Open source contributions are allowed to start small and grow over time","text":"If the standard for code contributions is that every PR needs to support every possible input type that anyone can think of, the barrier would be too high for newcomers. Instead, the principle is to be as correct as possible to begin with, and grow the generic support over time. All recommended functionality should be tested, any known generality issues should be documented in an issue (and with a @test_broken test when possible).","category":"section"},{"location":"developers/design-principles/#Generic-code-is-preferred-unless-code-is-known-to-be-specific","page":"Design Principles","title":"Generic code is preferred unless code is known to be specific","text":"For example, the code:\n\nfunction f(A, B)\n    for i in 1:length(A)\n        A[i] = A[i] + B[i]\n    end\nend\n\nwould not be preferred for two reasons. One is that it assumes A uses one-based indexing, which would fail in cases like OffsetArrays.jl and FFTViews.jl. Another issue is that it requires indexing, while not all array types support indexing (for example, CuArrays.jl). A more generic compatible implementation of this function would be to use broadcast, for example:\n\nfunction f(A, B)\n    @. A = A + B\nend\n\nwhich would allow support for a wider variety of array types.","category":"section"},{"location":"developers/design-principles/#Internal-types-should-match-the-types-used-by-users-when-possible","page":"Design Principles","title":"Internal types should match the types used by users when possible","text":"If f(A) takes the input of some collections and computes an output from those collections, then it should be expected that if the user gives A as an Array, the computation should be done via Arrays. If A was a CuArray, then it should be expected that the computation should be internally done using a CuArray (or appropriately error if not supported). For these reasons, constructing arrays via generic methods, like similar(A), is preferred when writing f instead of using non-generic constructors like Array(undef,size(A)) unless the function is documented as being non-generic.","category":"section"},{"location":"developers/design-principles/#Trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible","page":"Design Principles","title":"Trait definition and adherence to generic interface is preferred when possible","text":"Julia provides many interfaces, for example:\n\nIteration\nIndexing\nBroadcasting\n\nThose interfaces should be followed when possible. For example, when defining broadcast overloads, one should implement a BroadcastStyle as suggested by the documentation instead of simply attempting to bypass the broadcast system via copyto! overloads.\n\nWhen interface functions are missing, these should be added to an interface package, like ArrayInterface.jl. Such traits should be declared and used when appropriate. For example, if a line of code requires mutation, the trait ArrayInterface.ismutable(A) should be checked before attempting to mutate, and informative error messages should be written to capture the immutable case (or, an alternative code which does not mutate should be given).\n\nOne example of this principle is demonstrated in the generation of Jacobian matrices. In many scientific applications, one may wish to generate a Jacobian cache from the user's input u0. A naive way to generate this Jacobian is J = similar(u0,length(u0),length(u0)). However, this will generate a Jacobian J such that J isa Matrix.","category":"section"},{"location":"developers/design-principles/#Macros-should-be-limited-and-only-be-used-for-syntactic-sugar","page":"Design Principles","title":"Macros should be limited and only be used for syntactic sugar","text":"Macros define new syntax, and for this reason they tend to be less composable than other coding styles and require prior familiarity to be easily understood. One principle to keep in mind is, \"can the person reading the code easily picture what code is being generated?\". For example, a user of Soss.jl may not know what code is being generated by:\n\n@model (x, Î±) begin\n    Ïƒ ~ Exponential()\n    Î² ~ Normal()\n    y ~ For(x) do xj\n        Normal(Î± + Î² * xj, Ïƒ)\n    end\n    return y\nend\n\nand thus using such a macro as the interface is not preferred when possible. However, a macro like @muladd is trivial to picture on a code (it recursively transforms a*b + c to muladd(a,b,c) for more accuracy and efficiency), so using such a macro for example:\n\njulia> @macroexpand(@muladd k3 = f(t + c3 * dt, @. uprev + dt * (a031 * k1 + a032 * k2)))\n:(k3 = f((muladd)(c3, dt, t), (muladd).(dt, (muladd).(a032, k2, (*).(a031, k1)), uprev)))\n\nis recommended. Some macros in this category are:\n\n@inbounds\n@muladd\n@view\n@named\n@.\n@..\n\nSome performance macros, like @simd, @threads, or @turbo from LoopVectorization.jl, make an exception in that their generated code may be foreign to many users. However, they still are classified as appropriate uses as they are syntactic sugar since they do (or should) not change the behavior of the program in measurable ways other than performance.","category":"section"},{"location":"developers/design-principles/#Errors-should-be-caught-as-early-as-possible,-and-error-messages-should-be-made-contextually-clear-for-newcomers","page":"Design Principles","title":"Errors should be caught as early as possible, and error messages should be made contextually clear for newcomers","text":"Whenever possible, defensive programming should be used to check for potential errors before they are encountered deeper within a package. For example, if one knows that f(u0,p) will error unless u0 is the size of p, this should be caught at the start of the function to throw a domain specific error, for example \"parameters and initial condition should be the same size\".","category":"section"},{"location":"developers/design-principles/#Subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-Requires.jl","page":"Design Principles","title":"Subpackaging and interface packages is preferred over conditional modules via Requires.jl","text":"Requires.jl should be avoided at all costs. If an interface package exists, such as ChainRulesCore.jl for defining automatic differentiation rules without requiring a dependency on the whole ChainRules.jl system, or RecipesBase.jl which allows for defining Plots.jl plot recipes without a dependency on Plots.jl, a direct dependency on these interface packages is preferred.\n\nOtherwise, instead of resorting to a conditional dependency using Requires.jl, it is preferred one creates subpackages, i.e. smaller independent packages kept within the same GitHub repository with independent versioning and package management. An example of this is seen in Optimization.jl which has subpackages like OptimizationBBO.jl for BlackBoxOptim.jl support.\n\nSome important interface packages to be aware of include:\n\nChainRulesCore.jl\nRecipesBase.jl\nArrayInterface.jl\nCommonSolve.jl\nSciMLBase.jl","category":"section"},{"location":"developers/design-principles/#Functions-should-either-attempt-to-be-non-allocating-and-reuse-caches,-or-treat-inputs-as-immutable","page":"Design Principles","title":"Functions should either attempt to be non-allocating and reuse caches, or treat inputs as immutable","text":"Mutating codes and non-mutating codes fall into different worlds. When a code is fully immutable, the compiler can better reason about dependencies, optimize the code, and check for correctness. However, many times a code making the fullest use of mutation can outperform even what the best compilers of today can generate. That said, the worst of all worlds is when code mixes mutation with non-mutating code. Not only is this a mishmash of coding styles, it has the potential non-locality and compiler proof issues of mutating code while not fully benefiting from the mutation.","category":"section"},{"location":"developers/design-principles/#Out-of-place-and-immutability-is-preferred-when-sufficient-performant","page":"Design Principles","title":"Out-of-place and immutability is preferred when sufficient performant","text":"Mutation is used to get more performance by decreasing the amount of heap allocations. However, if it's not helpful for heap allocations in a given spot, do not use mutation. Mutation is scary and should be avoided unless it gives an immediate benefit. For example, if matrices are sufficiently large, then A*B is as fast as mul!(C,A,B), and thus writing A*B is preferred (unless the rest of the function is being careful about being fully non-allocating, in which case this should be mul! for consistency).\n\nSimilarly, when defining types, using struct is preferred to mutable struct unless mutating the struct is a common occurrence. Even if mutating the struct is a common occurrence, see whether using Setfield.jl is sufficient. The compiler will optimize the construction of immutable structs, and thus this can be more efficient if it's not too much of a code hassle.","category":"section"},{"location":"developers/design-principles/#Tests-should-attempt-to-cover-a-wide-gamut-of-input-types","page":"Design Principles","title":"Tests should attempt to cover a wide gamut of input types","text":"Code coverage numbers are meaningless if one does not consider the input types. For example, one can hit all the code with Array, but that does not test whether CuArray is compatible! Thus, it's always good to think of coverage not in terms of lines of code but in terms of type coverage. A good list of number types to think about are:\n\nFloat64\nFloat32\nComplex\nDual\nBigFloat\n\nArray types to think about testing are:\n\nArray\nOffsetArray\nCuArray","category":"section"},{"location":"developers/design-principles/#When-in-doubt,-a-submodule-should-become-a-subpackage-or-separate-package","page":"Design Principles","title":"When in doubt, a submodule should become a subpackage or separate package","text":"Each package should focus on one core idea. If there's something separate enough to be a submodule, could it instead be a separate well-tested and documented package to be used by other packages? Most likely yes.","category":"section"},{"location":"developers/design-principles/#Globals-should-be-avoided-whenever-possible","page":"Design Principles","title":"Globals should be avoided whenever possible","text":"Global variables should be avoided whenever possible. When required, global variables should be constants and have an all uppercase name separated with underscores (e.g. MY_CONSTANT). They should be defined at the top of the file, immediately after imports and exports but before an __init__ function. If you truly want mutable global style behavior you may want to look into mutable containers.","category":"section"},{"location":"developers/design-principles/#Type-stable-and-type-grounded-code-is-preferred-wherever-possible","page":"Design Principles","title":"Type-stable and type-grounded code is preferred wherever possible","text":"Type-stable and type-grounded code helps the compiler create not only more optimized code, but also faster to compile code. Always keep containers well-typed, functions specializing on the appropriate arguments, and types concrete.","category":"section"},{"location":"developers/design-principles/#Closures-should-be-avoided-whenever-possible","page":"Design Principles","title":"Closures should be avoided whenever possible","text":"Closures can cause accidental type instabilities that are difficult to track down and debug; in the long run it saves time to always program defensively and avoid writing closures in the first place, even when a particular closure would not have been problematic. A similar argument applies to reading code with closures; if someone is looking for type instabilities, this is faster to do when code does not contain closures. See examples here.\n\nFurthermore, if you want to update variables in an outer scope, do so explicitly with Refs or self defined structs.","category":"section"},{"location":"developers/design-principles/#Numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces","page":"Design Principles","title":"Numerical functionality should use the appropriate generic numerical interfaces","text":"While you can use A\\b to do a linear solve inside a package, that does not mean that you should. This interface is only sufficient for performing factorizations, and so that limits the scaling choices, the types of A that can be supported, etc. Instead, linear solves within packages should use LinearSolve.jl. Similarly, nonlinear solves should use NonlinearSolve.jl. Optimization should use Optimization.jl. Etc. This allows the full generic choice to be given to the user without depending on every solver package (effectively recreating the generic interfaces within each package).","category":"section"},{"location":"developers/design-principles/#Functions-should-capture-one-underlying-principle","page":"Design Principles","title":"Functions should capture one underlying principle","text":"Functions mean one thing. Every dispatch of + should be \"the meaning of addition on these types\". While in theory you could add dispatches to + that mean something different, that will fail in generic code for which + means addition. Thus, for generic code to work, code needs to adhere to one meaning for each function. Every dispatch should be an instantiation of that meaning.","category":"section"},{"location":"developers/design-principles/#Internal-choices-should-be-exposed-as-options-whenever-possible","page":"Design Principles","title":"Internal choices should be exposed as options whenever possible","text":"Whenever possible, numerical values and choices within scripts should be exposed as options to the user. This promotes code reusability beyond the few cases the author may have expected.","category":"section"},{"location":"developers/design-principles/#Prefer-code-reuse-over-rewrites-whenever-possible","page":"Design Principles","title":"Prefer code reuse over rewrites whenever possible","text":"If a package has a function you need, use the package. Add a dependency if you need to. If the function is missing a feature, prefer to add that feature to said package and then add it as a dependency. If the dependency is potentially troublesome, for example because it has a high load time, prefer to spend time helping said package fix these issues and add the dependency. Only when it does not seem possible to make the package \"good enough\" should using the package be abandoned. If it is abandoned, consider building a new package for this functionality as you need it, and then make it a dependency.","category":"section"},{"location":"developers/design-principles/#Prefer-to-not-shadow-functions","page":"Design Principles","title":"Prefer to not shadow functions","text":"In Julia, two functions can share the same name if they belong to different namespaces. For example, X.f and Y.f can be two different functions, with different dispatches, but the same name. This should be avoided whenever possible. Instead of creating MyPackage.sort, consider adding dispatches to Base.sort for your types if these new dispatches match the underlying principle of the function. If they don't, it would be preferable to use a different name. While using MyPackage.sort is not conflicting, it is going to be confusing for most people unfamiliar with your code, so MyPackage.special_sort would be more helpful to newcomers reading the code.","category":"section"},{"location":"man/magnetic_dataset/#Magnetic-dataset-(experimental)","page":"Magnetic dataset (experimental)","title":"Magnetic dataset (experimental)","text":"Pages = [\"magnetic_dataset.md\"]\nDepth = 2:3\n\nThe dataset is accessible through the C-structure given by\n\ndump(MagneticDataset)","category":"section"},{"location":"man/magnetic_dataset/#Magnetic-space-group-type","page":"Magnetic dataset (experimental)","title":"Magnetic space-group type","text":"","category":"section"},{"location":"man/magnetic_dataset/#uni_number","page":"Magnetic dataset (experimental)","title":"uni_number","text":"The serial number from 1 to 1651 of UNI or BNS symbols.","category":"section"},{"location":"man/magnetic_dataset/#msg_type","page":"Magnetic dataset (experimental)","title":"msg_type","text":"Magnetic space groups (MSG) is classified by its family space group (FSG) and maximal space subgroup (XSG). FSG is a non-magnetic space group obtained by ignoring time-reversal term in MSG. XSG is a space group obtained by picking out non time-reversal operations in MSG.\n\nmsg_type=1 (type-I): MSG, XSG, FSG are all isomorphic.\nmsg_type=2 (type-II): XSG and FSG are isomorphic, and MSG is generated from XSG and pure time reversal operations\nmsg_type=3 (type-III): XSG is a proper subgroup of MSG with isomorphic translational subgroups.\nmsg_type=4 (type-IV): XSG is a proper subgroup of MSG with isomorphic point group.","category":"section"},{"location":"man/magnetic_dataset/#hall_number","page":"Magnetic dataset (experimental)","title":"hall_number","text":"For type-I, II, III, hall number of FSG; for type-IV, that of XSG","category":"section"},{"location":"man/magnetic_dataset/#tensor_rank","page":"Magnetic dataset (experimental)","title":"tensor_rank","text":"0 for collinear spins, 1 for non-collinear spins","category":"section"},{"location":"man/magnetic_dataset/#Magnetic-symmetry-operations","page":"Magnetic dataset (experimental)","title":"Magnetic symmetry operations","text":"","category":"section"},{"location":"man/magnetic_dataset/#n_operations","page":"Magnetic dataset (experimental)","title":"n_operations","text":"Number of magnetic symmetry operations.","category":"section"},{"location":"man/magnetic_dataset/#rotations","page":"Magnetic dataset (experimental)","title":"rotations","text":"Rotation (matrix) parts of symmetry operations","category":"section"},{"location":"man/magnetic_dataset/#translations","page":"Magnetic dataset (experimental)","title":"translations","text":"Translation (vector) parts of symmetry operations","category":"section"},{"location":"man/magnetic_dataset/#time_reversals","page":"Magnetic dataset (experimental)","title":"time_reversals","text":"Time reversal part of magnetic symmetry operations. 1 indicates time reversal operation, and 0 indicates an ordinary operation.","category":"section"},{"location":"man/magnetic_dataset/#Symmetrically-equivalent-atoms","page":"Magnetic dataset (experimental)","title":"Symmetrically equivalent atoms","text":"","category":"section"},{"location":"man/magnetic_dataset/#n_atoms-and-equivalent_atoms","page":"Magnetic dataset (experimental)","title":"n_atoms and equivalent_atoms","text":"See equivalent_atoms.","category":"section"},{"location":"man/magnetic_dataset/#Transformation-to-standardized-setting","page":"Magnetic dataset (experimental)","title":"Transformation to standardized setting","text":"","category":"section"},{"location":"man/magnetic_dataset/#transformation_matrix-and-origin_shift","page":"Magnetic dataset (experimental)","title":"transformation_matrix and origin_shift","text":"See Transformation matrix and origin shift.","category":"section"},{"location":"man/magnetic_dataset/#Standardized-magnetic-crystal-structure-after-idealization","page":"Magnetic dataset (experimental)","title":"Standardized magnetic crystal structure after idealization","text":"","category":"section"},{"location":"man/magnetic_dataset/#n_std_atoms,-std_lattice,-std_types,-std_positions,-and-std_rotation_matrix","page":"Magnetic dataset (experimental)","title":"n_std_atoms, std_lattice, std_types, std_positions, and std_rotation_matrix","text":"See Standardized crystal structure after idealization.","category":"section"},{"location":"man/magnetic_dataset/#std_tensors","page":"Magnetic dataset (experimental)","title":"std_tensors","text":"Site tensors of the standardized crystal structure idealization.","category":"section"},{"location":"man/magnetic_dataset/#Intermediate-data-in-symmetry-search","page":"Magnetic dataset (experimental)","title":"Intermediate data in symmetry search","text":"","category":"section"},{"location":"man/magnetic_dataset/#primitive_lattice","page":"Magnetic dataset (experimental)","title":"primitive_lattice","text":"See primitive_lattice. primitive_lattice generates pure translations without time reversals. Thus, for type-IV magnetic space groups, a unit cell spanned by primitive_lattice contains an anti-translation lattice point.","category":"section"},{"location":"developers/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"Pages = [\"contributing.md\"]\nDepth = 2:3\n\nWelcome! This document explains some ways you can contribute to Spglib.","category":"section"},{"location":"developers/contributing/#Code-of-conduct","page":"Contributing","title":"Code of conduct","text":"This project and everyone participating in it is governed by the Contributor Covenant Code of Conduct. By participating, you are expected to uphold this code.","category":"section"},{"location":"developers/contributing/#Join-the-community-forum","page":"Contributing","title":"Join the community forum","text":"First up, join the community forum.\n\nThe forum is a good place to ask questions about how to use Spglib. You can also use the forum to discuss possible feature requests and bugs before raising a GitHub issue (more on this below).\n\nAside from asking questions, the easiest way you can contribute to Spglib is to help answer questions on the forum!","category":"section"},{"location":"developers/contributing/#Improve-the-documentation","page":"Contributing","title":"Improve the documentation","text":"Chances are, if you asked (or answered) a question on the community forum, then it is a sign that the documentation could be improved. Moreover, since it is your question, you are probably the best-placed person to improve it!\n\nThe docs are written in Markdown and are built using Documenter.jl. You can find the source of all the docs here.\n\nIf your change is small (like fixing typos or one or two sentence corrections), the easiest way to do this is via GitHub's online editor. (GitHub has help on how to do this.)\n\nIf your change is larger or touches multiple files, you will need to make the change locally and then use Git to submit a pull request. (See Contribute code to Spglib below for more on this.)","category":"section"},{"location":"developers/contributing/#File-a-bug-report","page":"Contributing","title":"File a bug report","text":"Another way to contribute to Spglib is to file bug reports.\n\nMake sure you read the info in the box where you write the body of the issue before posting. You can also find a copy of that info here.\n\ntip: Tip\nIf you're unsure whether you have a real bug, post on the community forum first. Someone will either help you fix the problem or let you know the most appropriate place to open a bug report.","category":"section"},{"location":"developers/contributing/#Contribute-code-to-Spglib","page":"Contributing","title":"Contribute code to Spglib","text":"Finally, you can also contribute code to Spglib!\n\nwarning: Warning\nIf you do not have experience with Git, GitHub, and Julia development, the first steps can be a little daunting. However, there are lots of tutorials available online, including:GitHub\nGit and GitHub\nGit\nJulia package development\n\nOnce you are familiar with Git and GitHub, the workflow for contributing code to Spglib is similar to the following:","category":"section"},{"location":"developers/contributing/#Step-1:-decide-what-to-work-on","page":"Contributing","title":"Step 1: decide what to work on","text":"The first step is to find an open issue (or open a new one) for the problem you want to solve. Then, before spending too much time on it, discuss what you are planning to do in the issue to see if other contributors are fine with your proposed changes. Getting feedback early can improve code quality and avoid time spent writing code that does not get merged into Spglib.\n\ntip: Tip\nAt this point, remember to be patient and polite; you may get a lot of comments on your issue! However, do not be afraid! Comments mean that people are willing to help you improve the code that you are contributing to Spglib.","category":"section"},{"location":"developers/contributing/#Step-2:-fork-Spglib","page":"Contributing","title":"Step 2: fork Spglib","text":"Go to https://github.com/singularitti/Spglib.jl and click the \"Fork\" button in the top-right corner. This will create a copy of Spglib under your GitHub account.","category":"section"},{"location":"developers/contributing/#Step-3:-install-Spglib-locally","page":"Contributing","title":"Step 3: install Spglib locally","text":"Similar to Installation Guide, open the Julia REPL and run:\n\nusing Pkg\nPkg.update()\nPkg.develop(\"Spglib\")\n\nThen the package will be cloned to your local machine. On *nix systems, the default path is ~/.julia/dev/Spglib unless you modify the JULIA_DEPOT_PATH environment variable. If you're on Windows, this will be C:\\\\Users\\\\<my_name>\\\\.julia\\\\dev\\\\Spglib. In the following text, we will call it PKGROOT.\n\nGo to PKGROOT, start a new Julia session, and run\n\nusing Pkg\nPkg.instantiate()\n\nto instantiate the project.","category":"section"},{"location":"developers/contributing/#Step-4:-checkout-a-new-branch","page":"Contributing","title":"Step 4: checkout a new branch","text":"note: Note\nIn the following, replace any instance of GITHUB_ACCOUNT with your GitHub username.\n\nThe next step is to check out a development branch. In a terminal (or command prompt on Windows), run:\n\n$ cd ~/.julia/dev/Spglib\n\n$ git remote add GITHUB_ACCOUNT https://github.com/GITHUB_ACCOUNT/Spglib.jl.git\n\n$ git checkout main\n\n$ git pull\n\n$ git checkout -b my_new_branch","category":"section"},{"location":"developers/contributing/#Step-5:-make-changes","page":"Contributing","title":"Step 5: make changes","text":"Now make any changes to the source code inside the ~/.julia/dev/Spglib directory.\n\nMake sure you:\n\nFollow our Style Guide and Run JuliaFormatter.\nAdd tests and documentation for any changes or new features.\n\ntip: Tip\nWhen you change the source code, you will need to restart Julia for the changes to take effect. If this is a pain, install Revise.jl.","category":"section"},{"location":"developers/contributing/#Step-6a:-test-your-code-changes","page":"Contributing","title":"Step 6a: test your code changes","text":"To test that your changes work, run the Spglib test-suite by opening Julia and running:\n\njulia> cd(joinpath(DEPOT_PATH[1], \"dev\", \"Spglib\"))\n\njulia> using Pkg\n\njulia> Pkg.activate(\".\")\n  Activating new project at `~/.julia/dev/Spglib`\n\njulia> Pkg.test()\n\nwarning: Warning\nRunning the tests might take a long time.\n\ntip: Tip\nIf you are using Revise.jl, you can also run the tests by calling include:include(\"test/runtests.jl\")This can be faster if you want to re-run the tests multiple times.","category":"section"},{"location":"developers/contributing/#Step-6b:-test-your-documentation-changes","page":"Contributing","title":"Step 6b: test your documentation changes","text":"Open Julia, then run:\n\njulia> cd(joinpath(DEPOT_PATH[1], \"dev\", \"Spglib\", \"docs\"))\n\njulia> using Pkg\n\njulia> Pkg.activate(\".\")\n  Activating new project at `~/.julia/dev/Spglib/docs`\n\njulia> include(\"src/make.jl\")\n\nAfter a while, a folder PKGROOT/docs/build will appear. Open PKGROOT/docs/build/index.html with your favorite browser, and have fun!\n\nwarning: Warning\nBuilding the documentation might take a long time.\n\ntip: Tip\nIf there's a problem with the tests that you don't know how to fix, don't worry. Continue to step 5, and one of the Spglib contributors will comment on your pull request, telling you how to fix things.","category":"section"},{"location":"developers/contributing/#Step-7:-make-a-pull-request","page":"Contributing","title":"Step 7: make a pull request","text":"Once you've made changes, you're ready to push the changes to GitHub. Run:\n\n$ cd ~/.julia/dev/Spglib\n\n$ git add .\n\n$ git commit -m \"A descriptive message of the changes\"\n\n$ git push -u GITHUB_ACCOUNT my_new_branch\n\nThen go to our pull request page and follow the instructions that pop up to open a pull request.","category":"section"},{"location":"developers/contributing/#Step-8:-respond-to-comments","page":"Contributing","title":"Step 8: respond to comments","text":"At this point, remember to be patient and polite; you may get a lot of comments on your pull request! However, do not be afraid! A lot of comments means that people are willing to help you improve the code that you are contributing to Spglib.\n\nTo respond to the comments, go back to step 5, make any changes, test the changes in step 6, and then make a new commit in step 7. Your PR will automatically update.","category":"section"},{"location":"developers/contributing/#Step-9:-cleaning-up","page":"Contributing","title":"Step 9: cleaning up","text":"Once the PR is merged, clean-up your Git repository, ready for the next contribution!\n\n$ cd ~/.julia/dev/Spglib\n\n$ git checkout main\n\n$ git pull\n\nnote: Note\nIf you have suggestions to improve this guide, please make a pull request! It's particularly helpful if you do this after your first pull request because you'll know all the parts that could be explained better.\n\nThanks for contributing to Spglib!","category":"section"},{"location":"man/dataset/#Spglib-dataset","page":"Spglib dataset","title":"Spglib dataset","text":"Pages = [\"dataset.md\"]\nDepth = 2:3\n\nThe dataset is accessible through the struct given by\n\ndump(Dataset)","category":"section"},{"location":"man/dataset/#Space-group-type","page":"Spglib dataset","title":"Space group type","text":"","category":"section"},{"location":"man/dataset/#spacegroup_number","page":"Spglib dataset","title":"spacegroup_number","text":"The space group type number defined in International Tables for Crystallography (ITA).","category":"section"},{"location":"man/dataset/#hall_number","page":"Spglib dataset","title":"hall_number","text":"The serial number from 1 to 530 which are found at list of space groups (Seto's web site). Be sure that this is not a standard crystallographic definition as far as the author of Spglib knows.","category":"section"},{"location":"man/dataset/#international_symbol","page":"Spglib dataset","title":"international_symbol","text":"The (full) Hermannâ€“Mauguin notation of space group type is given by .","category":"section"},{"location":"man/dataset/#hall_symbol","page":"Spglib dataset","title":"hall_symbol","text":"The Hall symbol is stored here.","category":"section"},{"location":"man/dataset/#choice","page":"Spglib dataset","title":"choice","text":"The information on unique axis, setting or cell choices.","category":"section"},{"location":"man/dataset/#Symmetry-operations","page":"Spglib dataset","title":"Symmetry operations","text":"","category":"section"},{"location":"man/dataset/#rotations,-translations,-and-n_operations","page":"Spglib dataset","title":"rotations, translations, and n_operations","text":"The symmetry operations of the input unit cell are stored in rotations and translations. A crystallographic symmetry operation (mathbfW mathbfw) is made from a pair of rotation mathbfW and translation mathbfw parts with the same index. Number of symmetry operations is given as n_operations. The detailed explanation of the values is found at get_symmetry.","category":"section"},{"location":"man/dataset/#Wyckoff-positions-and-symmetrically-equivalent-atoms","page":"Spglib dataset","title":"Wyckoff positions and symmetrically equivalent atoms","text":"","category":"section"},{"location":"man/dataset/#n_atoms","page":"Spglib dataset","title":"n_atoms","text":"Number of atoms in the input unit cell. This gives the numbers of elements in wyckoffs and equivalent_atoms.","category":"section"},{"location":"man/dataset/#wyckoffs","page":"Spglib dataset","title":"wyckoffs","text":"This gives the information of Wyckoff letters by integer numbers, where 0, 1, 2, ldots, represent the Wyckoff letters of a, b, c, ldots These are assigned to all atomic positions of the input unit cell in this order. Therefore the number of elements in wyckoffs is same as the number of atoms in the input unit cell, which is given by n_atoms.\n\nThis is determined from the symmetry of the primitive cell.","category":"section"},{"location":"man/dataset/#site_symmetry_symbols","page":"Spglib dataset","title":"site_symmetry_symbols","text":"This gives site-symmetry symbols. These are valid for the standard settings. For different settings and choices belonging to the same space group type, the same set of the symbols is returned.\n\nThis is determined from the symmetry of the primitive cell.","category":"section"},{"location":"man/dataset/#equivalent_atoms","page":"Spglib dataset","title":"equivalent_atoms","text":"This gives the mapping table from the atomic indices of the input unit cell to the atomic indices of symmetrically independent atom, such as [1, 1, 1, 1, 5, 5, 5, 5], where the symmetrically independent atomic indices are 1 and 5. We can see that the atoms from 1 to 4 are mapped to 1 and those from 5 to 8 are mapped to 5.  The number of elements in equivalent_atoms is same as the number of atoms in the input unit cell, which is given by n_atoms.\n\nwarning: Warning\nYou may notice that the indices here differ from those in Spglib's official documentation, where the indices start from 0. This discrepancy arises because indices in Julia start from 1 by default. Consequently, all indices here are incremented by 1.\n\nSymmetry operations found for the input cell are used to determine the equivalent atoms. equivalent_atoms and crystallographic_orbits are almost equivalent, but they can be different in a special case as written in get_symmetry.","category":"section"},{"location":"man/dataset/#crystallographic_orbits","page":"Spglib dataset","title":"crystallographic_orbits","text":"This is almost equivalent to equivalent_atoms. But symmetry of the primitive cell is used to determine the symmetrically equivalent atoms.","category":"section"},{"location":"man/dataset/#Transformation-matrix-and-origin-shift","page":"Spglib dataset","title":"Transformation matrix and origin shift","text":"","category":"section"},{"location":"man/dataset/#transformation_matrix-and-origin_shift","page":"Spglib dataset","title":"transformation_matrix and origin_shift","text":"transformation_matrix (mathbfP) and origin_shift (mathbfp) are obtained as a result of space-group-type matching under a set of unique axis, setting and cell choices. These are operated to the basis vectors and atomic point coordinates of the input unit cell as\n\nbeginalign\n    beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix =\n    beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix mathbfP^-1\n    mathbfx_texts = mathbfP mathbfx + mathbfp  (mathrmmod mathbf1)\nendalign\n\nby which the basis vectors are transformed to those of a standardized unit cell. Atomic point coordinates are shifted so that symmetry operations have one of possible standard origins. The detailed definition is presented at Definitions and conventions.","category":"section"},{"location":"man/dataset/#Standardized-crystal-structure-after-idealization","page":"Spglib dataset","title":"Standardized crystal structure after idealization","text":"","category":"section"},{"location":"man/dataset/#n_std_atoms,-std_lattice,-std_types,-and-std_positions","page":"Spglib dataset","title":"n_std_atoms, std_lattice, std_types, and std_positions","text":"The standardized crystal structure after idealization corresponding to a Hall symbol is stored in n_std_atoms, std_lattice, std_types, and std_positions. These output usually contains the rotation in Cartesian coordinates and rearrangement of the order atoms with respect to the input unit cell.","category":"section"},{"location":"man/dataset/#std_rotation_matrix","page":"Spglib dataset","title":"std_rotation_matrix","text":"Rotation matrix that rotates the standardized crystal structure before idealization beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix to that after idealization beginbmatrix barmathbfa_texts  barmathbfb_texts  barmathbfc_texts endbmatrix in Cartesian coordinates of the given input unit cell. The rotation matrix mathbfR is defined by\n\nbeginbmatrix barmathbfa_texts  barmathbfb_texts  barmathbfc_texts endbmatrix =\nbeginbmatrix mathbfR mathbfa_texts  mathbfR mathbfb_texts  mathbfR mathbfc_texts endbmatrix\n\nMore precisely, this rotation matrix is an orthonormal matrix. Since beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix can be distored, to make mathbfR orthonormal, it is calculated as follows. Make cubes of beginbmatrix mathbfa_texts  mathbfb_texts  mathbfc_texts endbmatrix and beginbmatrix barmathbfa_texts  barmathbfb_texts  barmathbfc_texts endbmatrix by\n\nmathbfL = beginbmatrix\ndfracmathbfalvertmathbfarvert \ndfrac(mathbfa times mathbfb) times mathbfalvert(mathbfa times mathbfb) times mathbfarvert \ndfracmathbfa times mathbfblvertmathbfa times mathbfbrvert\nendbmatrix\n\nWatching mathbfL_texts as 3times 3 matrices, mathbfR is obtained by solving\n\nbarmathbfL_texts = mathbfR mathbfL_texts","category":"section"},{"location":"man/dataset/#std_mapping_to_primitive","page":"Spglib dataset","title":"std_mapping_to_primitive","text":"This gives a list of atomic indices in the primitive cell of the standardized crystal structure, where the same number presents the same atom in the primitive cell. By collective the atoms having the same number, a set of relative lattice points in the standardized crystal structure is obtained.","category":"section"},{"location":"man/dataset/#Crystallographic-point-group","page":"Spglib dataset","title":"Crystallographic point group","text":"","category":"section"},{"location":"man/dataset/#pointgroup_symbol","page":"Spglib dataset","title":"pointgroup_symbol","text":"pointgroup_symbol is the symbol of the crystallographic point group in the Hermannâ€“Mauguin notation. There are 32 crystallographic point groups\n\n1 bar1 2 m 2m 222 mm2 mmm 4 bar4 4m 422 4mm bar42m 4mmm 3 bar3 32 3m bar3m 6 bar6 6m 622 6mm bar6m2 6mmm 23 mbar3 432 bar43m mbar3m","category":"section"},{"location":"man/dataset/#Intermediate-data-in-symmetry-search","page":"Spglib dataset","title":"Intermediate data in symmetry search","text":"A primitive cell is searched from the translational symmetry. This primitive cell is given by primitive_lattice and mapping_to_primitive below.","category":"section"},{"location":"man/dataset/#primitive","page":"Spglib dataset","title":"primitive_lattice","text":"Non-standardized basis vectors of a primitive cell in the input cell.","category":"section"},{"location":"man/dataset/#mapping_to_primitive","page":"Spglib dataset","title":"mapping_to_primitive","text":"This gives a list of atomic indices in the primitive cell of the input crystal structure, where the same number presents the same atom in the primitive cell. By collective the atoms having the same number, a set of relative lattice points in the input crystal structure is obtained.","category":"section"},{"location":"#Spglib","page":"Home","title":"Spglib","text":"Documentation for Spglib.\n\nSee the Index for the complete list of documented functions and types.\n\nThe code, which is hosted on GitHub, is tested using various continuous integration services for its validity.\n\nThis repository is created and maintained by @singularitti, and contributions are highly welcome.","category":"section"},{"location":"#Package-features","page":"Home","title":"Package features","text":"Spglib.jl is a Julia wrapper of the C library Spglib. See this page. It is used for finding and handling crystal symmetries.\n\nThere was a package LibSymspg.jl thanks to @unkcpz. However, it is no longer actively maintained.\n\nThis package:\n\nenables the finding and handling of crystal symmetries;\nincludes new naming conventions, input types, and return types of functions.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg mode and run:\n\npkg> add Spglib\n\nOr, equivalently, via Pkg.jl:\n\nimport Pkg; Pkg.add(\"Spglib\")","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"STABLE â€” documentation of the most recently tagged version.\nDEV â€” documentation of the in-development version.","category":"section"},{"location":"#Project-status","page":"Home","title":"Project status","text":"The package is developed for and tested against Julia v1.6 and above on Linux, macOS, and Windows.","category":"section"},{"location":"#Questions-and-contributions","page":"Home","title":"Questions and contributions","text":"You can post usage questions on our discussion page.\n\nWe welcome contributions, feature requests, and suggestions. If you encounter any problems, please open an issue. The Contributing page has a few guidelines that should be followed when opening pull requests and contributing code.","category":"section"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"Pages = [\n    \"man/installation.md\",\n    \"man/definitions.md\",\n    \"man/dataset.md\",\n    \"man/magnetic_dataset.md\",\n    \"man/examples.md\",\n    \"man/troubleshooting.md\",\n    \"developers/contributing.md\",\n    \"developers/style-guide.md\",\n    \"developers/design-principles.md\",\n]\nDepth = 3","category":"section"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"Pages = [\"lib/public.md\", \"lib/internals/error.md\", \"lib/internals/reciprocal.md\"]","category":"section"},{"location":"#main-index","page":"Home","title":"Index","text":"Pages = [\"lib/public.md\"]","category":"section"}]
}
